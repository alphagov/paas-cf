groups:
  - name: all
    jobs:
      - pipeline-lock
      - init
      - bosh-terraform
      - generate-bosh-config
      - bosh-deploy
      - generate-cf-secrets
      - cf-terraform
      - generate-cf-config
      - cf-deploy
      - post-deploy
      - smoke-tests
      - acceptance-tests
      - custom-acceptance-tests
      - bosh-cli-test
      - performance-tests
      - tag-release
      - pipeline-unlock
  - name: bosh
    jobs:
      - init
      - bosh-terraform
      - generate-bosh-config
      - bosh-deploy
  - name: cloudfoundry
    jobs:
      - generate-cf-secrets
      - cf-terraform
      - generate-cf-config
      - cf-deploy
      - post-deploy
      - smoke-tests
      - acceptance-tests
      - custom-acceptance-tests
      - bosh-cli-test
      - performance-tests
      - tag-release
      - pipeline-unlock
  - name: operator
    jobs:
      - generate-git-keys
      - show-release-version
      - bump-minor-version
      - bump-major-version
      - bump-patch-version
      - pipeline-check-lock
      - pipeline-release-lock
  - name: tests
    jobs:
      - smoke-tests
      - acceptance-tests
      - custom-acceptance-tests
      - bosh-cli-test
  - name: health
    jobs:
      - continuous-smoke-tests

resources:
  - name: pipeline-trigger
    type: semver-iam
    source:
      bucket: {{state_bucket}}
      region_name: {{aws_region}}
      key: {{pipeline_trigger_file}}

  - name: paas-cf
    type: git
    source:
      uri: https://github.com/alphagov/paas-cf.git
      branch: {{branch_name}}
      tag_filter: {{paas_cf_tag_filter}}

  - name: graphite-statsd-boshrelease
    type: git
    source:
      uri: https://github.com/alphagov/paas-graphite-statsd-boshrelease.git
      tag_filter: {{cf_graphite_version}}

  - name: grafana-boshrelease
    type: git
    source:
      uri: https://github.com/alphagov/paas-grafana-boshrelease.git
      tag_filter: {{cf_grafana_version}}

  - name: graphite-nozzle
    type: git
    source:
      uri: https://github.com/alphagov/graphite-nozzle
      branch: 106191208-deaggregated_names

  - name: vpc-tfstate
    type: s3-iam
    source:
      bucket: {{state_bucket}}
      region_name: {{aws_region}}
      versioned_file: vpc.tfstate

  - name: concourse-tfstate
    type: s3-iam
    source:
      bucket: {{state_bucket}}
      versioned_file: concourse.tfstate
      region_name: eu-west-1

  - name: bosh-tfstate
    type: s3-iam
    source:
      bucket: {{state_bucket}}
      region_name: {{aws_region}}
      versioned_file: bosh.tfstate

  - name: bosh-secrets
    type: s3-iam
    source:
      bucket: {{state_bucket}}
      region_name: {{aws_region}}
      versioned_file: bosh-secrets.yml

  - name: bosh-CA
    type: s3-iam
    source:
      bucket: {{state_bucket}}
      region_name: {{aws_region}}
      versioned_file: bosh-CA.tar.gz

  - name: concourse-manifest
    type: s3-iam
    source:
      bucket: {{state_bucket}}
      region_name: {{aws_region}}
      versioned_file: concourse-manifest.yml

  - name: bosh-manifest
    type: s3-iam
    source:
      bucket: {{state_bucket}}
      region_name: {{aws_region}}
      versioned_file: bosh-manifest.yml

  - name: bosh-init-state
    type: s3-iam
    source:
      bucket: {{state_bucket}}
      region_name: {{aws_region}}
      versioned_file: bosh-manifest-state.json

  - name: ssh-private-key
    type: s3-iam
    source:
      bucket: {{state_bucket}}
      versioned_file: id_rsa
      region_name: {{aws_region}}

  - name: git-ssh-private-key
    type: s3-iam
    source:
      bucket: {{state_bucket}}
      versioned_file: git_id_rsa
      region_name: {{aws_region}}

  - name: cf-tfstate
    type: s3-iam
    source:
      bucket: {{state_bucket}}
      versioned_file: cf.tfstate
      region_name: eu-west-1

  - name: cf-secrets
    type: s3-iam
    source:
      bucket: {{state_bucket}}
      region_name: {{aws_region}}
      versioned_file: cf-secrets.yml

  - name: cf-certs
    type: s3-iam
    source:
      bucket: {{state_bucket}}
      region_name: {{aws_region}}
      versioned_file: cf-certs.tar.gz

  - name: cf-certs-tfstate
    type: s3-iam
    source:
      bucket: {{state_bucket}}
      versioned_file: cf-certs.tfstate
      region_name: eu-west-1

  - name: cf-manifest
    type: s3-iam
    source:
      bucket: {{state_bucket}}
      region_name: {{aws_region}}
      versioned_file: cf-manifest.yml

  - name: cf-release
    type: git
    source:
      uri: https://github.com/cloudfoundry/cf-release
      tag_filter: {{cf-release-version}}

  - name: git-keys
    type: s3-iam
    source:
      bucket: {{state_bucket}}
      region_name: {{aws_region}}
      versioned_file: git-keys.tar.gz

  - name: release-version
    type: semver-iam
    source:
      bucket: {{state_bucket}}
      region_name: {{aws_region}}
      key: release-version
      initial_version: 0.0.0

  - name: pipeline-pool
    type: pool
    source:
      uri: {{git_concourse_pool_clone_full_url_ssh}}
      branch: master
      pool: {{pipeline_name}}
      private_key: {{pipeline_lock_git_private_key}}

  - name: smoke-tests-timer
    type: time
    source:
      interval: 5m

jobs:
  - name: pipeline-lock
    serial: true
    plan:
      - get: paas-cf
        trigger: {{auto_deploy}}
      - get: git-ssh-private-key
      - task: init-pipeline-pool
        config:
          platform: linux
          image: docker:///governmentpaas/git-ssh
          inputs:
            - name: paas-cf
            - name: git-ssh-private-key
          params:
            DEPLOY_ENV: {{deploy_env}}
            AWS_ACCOUNT: {{aws_account}}
          run:
            path: sh
            args:
            - -e
            - -c
            - |
              chmod 600 git-ssh-private-key/git_id_rsa
              git config --global push.default simple
              git config --global user.email "concourse@${DEPLOY_ENV}.${AWS_ACCOUNT}"
              git config --global user.name "Concourse server ${DEPLOY_ENV} in ${AWS_ACCOUNT}"

              ./paas-cf/concourse/scripts/create_pool_lock.sh \
                {{git_concourse_pool_clone_full_url_ssh}} \
                $(pwd)/git-ssh-private-key/git_id_rsa \
                {{pipeline_name}} lock
      - put: pipeline-pool
        params:
          claim: lock
      - put: pipeline-trigger
        params: {bump: patch}

  - name: init
    serial_groups: [bosh-deploy]
    serial: true
    plan:
      - get: pipeline-trigger
        trigger: true
        passed: [pipeline-lock]
      - get: paas-cf
        passed: [pipeline-lock]
      - get: concourse-manifest
      - task: self-update-pipeline
        config:
          platform: linux
          image: docker:///governmentpaas/self-update-pipelines
          inputs:
            - name: paas-cf
            - name: concourse-manifest
          params:
            DEPLOY_ENV: {{deploy_env}}
            BRANCH: {{branch_name}}
            MAKEFILE_ENV_TARGET: {{makefile_env_target}}
            SELF_UPDATE_PIPELINE: {{self_update_pipeline}}
            PIPELINES_TO_UPDATE: {{pipeline_name}}
          run:
            path: ./paas-cf/concourse/scripts/self-update-pipeline.sh

      - task: bootstrap-s3-state
        config:
          platform: linux
          image: docker:///governmentpaas/curl-ssl
          inputs:
            - name: paas-cf
          run:
            path: sh
            args:
              - -e
              - -c
              - |
                paas-cf/concourse/scripts/s3init.sh {{state_bucket}} bosh.tfstate paas-cf/concourse/init_files/terraform.tfstate.tpl
                paas-cf/concourse/scripts/s3init.sh {{state_bucket}} bosh-manifest-state.json paas-cf/concourse/init_files/bosh-init-state.json.tpl
                paas-cf/concourse/scripts/s3init.sh {{state_bucket}} bosh-secrets.yml paas-cf/concourse/init_files/zero_bytes
                paas-cf/concourse/scripts/s3init.sh {{state_bucket}} bosh-CA.tar.gz paas-cf/concourse/init_files/empty.tar.gz
                paas-cf/concourse/scripts/s3init.sh {{state_bucket}} cf-secrets.yml paas-cf/concourse/init_files/zero_bytes
                paas-cf/concourse/scripts/s3init.sh {{state_bucket}} cf.tfstate paas-cf/concourse/init_files/terraform.tfstate.tpl
                paas-cf/concourse/scripts/s3init.sh {{state_bucket}} cf-certs.tar.gz paas-cf/concourse/init_files/empty.tar.gz
                paas-cf/concourse/scripts/s3init.sh {{state_bucket}} cf-certs.tfstate paas-cf/concourse/init_files/terraform.tfstate.tpl
                paas-cf/concourse/scripts/s3init.sh {{state_bucket}} git-keys.tar.gz paas-cf/concourse/init_files/empty.tar.gz

  - name: bosh-terraform
    serial_groups: [bosh-deploy]
    serial: true
    plan:
      - aggregate:
          - get: pipeline-trigger
            trigger: true
            passed: [ init ]
          - get: paas-cf
            passed: [init]
          - get: vpc-tfstate
          - get: concourse-tfstate
          - get: bosh-tfstate

      - task: extract-terraform-variables
        config:
          platform: linux
          image: docker:///ruby#2.2-slim
          inputs:
            - name: paas-cf
            - name: vpc-tfstate
            - name: concourse-tfstate
          outputs:
            - name: terraform-variables
          run:
            path: sh
            args:
              - -e
              - -c
              - |
                ruby paas-cf/concourse/scripts/extract_tf_vars_from_terraform_state.rb \
                < vpc-tfstate/vpc.tfstate \
                > terraform-variables/vpc.tfvars.sh
                ruby paas-cf/concourse/scripts/extract_tf_vars_from_terraform_state.rb \
                < concourse-tfstate/concourse.tfstate \
                > terraform-variables/concourse.tfvars.sh
      - task: terraform-apply
        config:
          platform: linux
          image: docker:///governmentpaas/terraform
          inputs:
            - name: paas-cf
            - name: terraform-variables
            - name: bosh-tfstate
          outputs:
            - name: updated-bosh-tfstate
          params:
            DEPLOY_ENV: {{deploy_env}}
            AWS_DEFAULT_REGION: {{aws_region}}
          run:
            path: sh
            args:
              - -e
              - -c
              - |
                . terraform-variables/vpc.tfvars.sh
                . terraform-variables/concourse.tfvars.sh

                terraform apply -var env={{deploy_env}} -var-file=paas-cf/terraform/{{aws_account}}.tfvars \
                  -state=bosh-tfstate/bosh.tfstate -state-out=updated-bosh-tfstate/bosh.tfstate paas-cf/terraform/bosh
        ensure:
          put: bosh-tfstate
          params:
            file: updated-bosh-tfstate/bosh.tfstate

  - name: generate-bosh-config
    serial_groups: [bosh-deploy]
    serial: true
    plan:
      - aggregate:
          - get: pipeline-trigger
            trigger: true
            passed: ['bosh-terraform']
          - get: paas-cf
            passed: ['bosh-terraform']
          - get: bosh-secrets
          - get: bosh-CA
          - get: vpc-tfstate
            passed: ['bosh-terraform']
          - get: bosh-tfstate
            passed: ['bosh-terraform']

      - aggregate:
          - task: generate-secrets
            config:
              platform: linux
              image: docker:///ruby#2.2-slim
              inputs:
                - name: paas-cf
                - name: bosh-secrets
                  path: existing-bosh-secrets
              outputs:
                - name: generated-bosh-secrets
              run:
                path: sh
                args:
                  - -e
                  - -c
                  - |
                    ./paas-cf/manifests/bosh-manifest/scripts/generate-bosh-secrets.rb \
                      --existing-secrets existing-bosh-secrets/bosh-secrets.yml \
                      > generated-bosh-secrets/bosh-secrets.yml
                    ls -l generated-bosh-secrets
            on_success:
              put: bosh-secrets
              params:
                file: generated-bosh-secrets/bosh-secrets.yml
          - task: generate-bosh-CA
            config:
              platform: linux
              image: docker:///governmentpaas/certstrap
              inputs:
                - name: paas-cf
                - name: bosh-CA
                  path: existing-bosh-CA
              outputs:
                - name: generated-bosh-CA
              run:
                path: sh
                args:
                  - -e
                  - -c
                  - |
                    if  [ -z "$(tar -tvzf existing-bosh-CA/bosh-CA.tar.gz)" ] ; then
                      certstrap init --passphrase "" --common-name bosh-CA
                      cd out
                      tar -cvzf ../generated-bosh-CA/bosh-CA.tar.gz bosh-CA.*
                      cd ..
                    else
                      echo "The CA cert already exists, skipping generation..."
                      cp existing-bosh-CA/bosh-CA.tar.gz generated-bosh-CA/bosh-CA.tar.gz
                      mkdir out
                      tar -xvzf generated-bosh-CA/bosh-CA.tar.gz -C out
                    fi
                    ./paas-cf/concourse/scripts/file-to-yaml.sh secrets bosh_ca_cert out/bosh-CA.crt > generated-bosh-CA/bosh-ca-cert.yml
            on_success:
              put: bosh-CA
              params:
                file: generated-bosh-CA/bosh-CA.tar.gz
          - task: extract_terraform_outputs
            config:
              platform: linux
              image: docker:///ruby#2.2-slim
              inputs:
                - name: paas-cf
                - name: vpc-tfstate
                - name: bosh-tfstate
              outputs:
                - name: terraform-outputs
              run:
                path: sh
                args:
                  - -c
                  - -e
                  - |
                    ruby paas-cf/concourse/scripts/extract_terraform_state_to_yaml.rb \
                      < vpc-tfstate/vpc.tfstate \
                      > terraform-outputs/vpc.terraform-outputs.yml
                    ruby paas-cf/concourse/scripts/extract_terraform_state_to_yaml.rb \
                      < bosh-tfstate/bosh.tfstate \
                      > terraform-outputs/bosh.terraform-outputs.yml

      - task: render-manifest
        config:
          platform: linux
          image: docker:///governmentpaas/spruce
          inputs:
            - name: paas-cf
            - name: terraform-outputs
            - name: generated-bosh-secrets
            - name: generated-bosh-CA
          outputs:
            - name: bosh-manifest
          params:
            BOSH_MANIFEST_STUBS: |
              ./generated-bosh-secrets/bosh-secrets.yml
              ./generated-bosh-CA/bosh-ca-cert.yml
              ./terraform-outputs/bosh.terraform-outputs.yml
              ./terraform-outputs/vpc.terraform-outputs.yml
          run:
            path: sh
            args:
              - -e
              - -c
              - |
                ./paas-cf/manifests/bosh-manifest/build_manifest.sh $BOSH_MANIFEST_STUBS > bosh-manifest/bosh-manifest.yml
                /bin/cat bosh-manifest/bosh-manifest.yml
        on_success:
          put: bosh-manifest
          params:
            file: bosh-manifest/bosh-manifest.yml

  - name: bosh-deploy
    serial_groups: [bosh-deploy]
    serial: true
    plan:
      - aggregate:
          - get: pipeline-trigger
            passed: ['generate-bosh-config']
            trigger: true
          - get: bosh-manifest
            passed: ['generate-bosh-config']
          - get: bosh-init-state
          - get: ssh-private-key

      - task: bosh-init-microbosh
        config:
          platform: linux
          image: docker:///governmentpaas/bosh-init
          inputs:
            - name: bosh-manifest
            - name: bosh-init-state
            - name: ssh-private-key
          outputs:
            - name: updated-bosh-init-state
          run:
            path: sh
            args:
              - -e
              - -c
              - |
                mkdir -p bosh-manifest/.ssh
                cp ssh-private-key/id_rsa bosh-manifest/.ssh/id_rsa
                chmod 400 bosh-manifest/.ssh/id_rsa
                cp bosh-init-state/bosh-manifest-state.json bosh-manifest/bosh-manifest-state.json
                bosh-init deploy bosh-manifest/bosh-manifest.yml
                cp bosh-manifest/bosh-manifest-state.json updated-bosh-init-state/bosh-manifest-state.json
        ensure:
          put: bosh-init-state
          params:
            file: updated-bosh-init-state/bosh-manifest-state.json

  - name: generate-cf-secrets
    serial_groups: [cf-deploy]
    serial: true
    plan:
      - aggregate:
          - get: paas-cf
            passed: ['generate-bosh-config']
          - get: pipeline-trigger
            passed: ['generate-bosh-config']
            trigger: true
          - get: bosh-CA
          - get: cf-certs
          - get: cf-secrets
          - get: vpc-tfstate
          - get: concourse-tfstate
          - get: bosh-tfstate

      - task: generate-cf-secrets
        config:
          platform: linux
          image: docker:///ruby#2.2-slim
          inputs:
            - name: paas-cf
            - name: cf-secrets
              path: existing-cf-secrets
            - name: bosh-tfstate
          outputs:
            - name: generated-cf-secrets
          run:
            path: sh
            args:
              - -c
              - -e
              - |
                ./paas-cf/manifests/cf-manifest/scripts/generate-cf-secrets.rb \
                  --existing-secrets existing-cf-secrets/cf-secrets.yml \
                  > generated-cf-secrets/cf-secrets.yml
                ls -l generated-cf-secrets
        on_success:
          put: cf-secrets
          params:
            file: generated-cf-secrets/cf-secrets.yml

      - task: generate-cf-certs
        config:
          platform: linux
          image: docker:///governmentpaas/certstrap
          inputs:
            - name: bosh-CA
            - name: paas-cf
            - name: cf-certs
          outputs:
            - name: generated-cf-certs
          params:
            SYSTEM_DNS_ZONE_NAME: {{system_dns_zone_name}}
            APPS_DNS_ZONE_NAME: {{apps_dns_zone_name}}
          run:
            path: sh
            args:
              - -e
              - -c
              - |
                mkdir certs
                echo "Extracting extant certs"
                tar -xvzf cf-certs/cf-certs.tar.gz -C certs

                ./paas-cf/manifests/cf-manifest/scripts/generate-cf-certs.sh certs bosh-CA/bosh-CA.tar.gz

                echo "Generating uaa_jwt_signing public key from private key"
                openssl rsa -pubout -in certs/uaa_jwt_signing.key -out certs/uaa_jwt_verification.pem

                echo "Creating updated cert tarball"
                cd certs
                tar -cvzf ../generated-cf-certs/cf-certs.tar.gz .
        on_success:
          put: cf-certs
          params:
            file: generated-cf-certs/cf-certs.tar.gz

  - name: cf-terraform
    serial_groups: [cf-deploy]
    serial: true
    plan:
      - aggregate:
          - get: paas-cf
            passed: ['generate-cf-secrets']
          - get: pipeline-trigger
            passed: [ 'generate-cf-secrets' ]
            trigger: true
          - get: vpc-tfstate
          - get: concourse-tfstate
          - get: bosh-tfstate
          - get: cf-tfstate
          - get: cf-certs-tfstate
          - get: cf-certs
            passed: ['generate-cf-secrets']
          - get: cf-secrets
            passed: ['generate-cf-secrets']

      - task: upload-certs-to-aws
        config:
          platform: linux
          image: docker:///governmentpaas/terraform
          inputs:
            - name: paas-cf
            - name: cf-certs-tfstate
            - name: cf-certs
          outputs:
            - name: updated-tfstate
          params:
            TF_VAR_env: {{deploy_env}}
            SKIP_UPLOAD_GENERATED_CERTS: {{skip_upload_generated_certs}}
          run:
            path: sh
            args:
              - -e
              - -c
              - |
                if [ "${SKIP_UPLOAD_GENERATED_CERTS}" == "true" ]; then
                  cp cf-certs-tfstate/cf-certs.tfstate updated-tfstate/cf-certs.tfstate
                  echo "Using pre-uploaded public certificates for ${TF_VAR_env}"
                else
                  mkdir generated-certificates
                  tar xzf cf-certs/cf-certs.tar.gz -C generated-certificates

                  terraform apply -var-file=paas-cf/terraform/{{aws_account}}.tfvars \
                    -var router_external_crt="$(cat generated-certificates/router_external.crt)" \
                    -var router_external_key="$(cat generated-certificates/router_external.key)" \
                    -state=cf-certs-tfstate/cf-certs.tfstate \
                    -state-out=updated-tfstate/cf-certs.tfstate \
                    paas-cf/terraform/cf-certs
                fi
        ensure:
          put: cf-certs-tfstate
          params:
            file: updated-tfstate/cf-certs.tfstate

      - task: retrieve-pingdom-probes-ips
        config:
          platform: linux
          image: docker:///governmentpaas/curl-ssl
          inputs:
            - name: paas-cf
          outputs:
            - name: pingdom-probes-ips
          run:
            path: sh
            args:
              - -e
              - -c
              - |
                curl -Lfqs https://www.pingdom.com/rss/probe_servers.xml > probe_servers.xml
                IPS_PER_BLOCK=32
                cat probe_servers.xml | \
                  grep -o '[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}' | \
                  sort | uniq | sed 's/$/\/32/' | xargs -n ${IPS_PER_BLOCK} | tr ' ' ',' | \
                  awk '{print "export TF_VAR_pingdom_probe_cidrs_" NR-1 "=" $0}'\
                  > pingdom-probes-ips/pingdom-probes-ips.sh

      - task: extract-terraform-variables
        config:
          platform: linux
          image: docker:///ruby#2.2-slim
          inputs:
            - name: paas-cf
            - name: vpc-tfstate
            - name: concourse-tfstate
            - name: bosh-tfstate
            - name: cf-secrets
            - name: cf-certs-tfstate
          outputs:
            - name: terraform-variables
          run:
            path: sh
            args:
              - -e
              - -c
              - |
                ruby paas-cf/concourse/scripts/extract_tf_vars_from_terraform_state.rb \
                < vpc-tfstate/vpc.tfstate > terraform-variables/vpc.tfvars.sh
                ruby paas-cf/concourse/scripts/extract_tf_vars_from_terraform_state.rb \
                < concourse-tfstate/concourse.tfstate > terraform-variables/concourse.tfvars.sh
                ruby paas-cf/concourse/scripts/extract_tf_vars_from_terraform_state.rb \
                < bosh-tfstate/bosh.tfstate > terraform-variables/bosh.tfvars.sh
                ruby paas-cf/concourse/scripts/extract_tf_vars_from_terraform_state.rb \
                < cf-certs-tfstate/cf-certs.tfstate > terraform-variables/cf-certs.tfvars.sh
                ruby paas-cf/concourse/scripts/extract_tf_vars_from_yaml.rb \
                < cf-secrets/cf-secrets.yml > terraform-variables/cf-secrets.tfvars.sh
      - task: terraform-apply
        config:
          platform: linux
          image: docker:///governmentpaas/terraform
          inputs:
            - name: terraform-variables
            - name: paas-cf
            - name: cf-tfstate
            - name: cf-certs
            - name: pingdom-probes-ips
          outputs:
            - name: updated-tfstate
          params:
            TF_VAR_env: {{deploy_env}}
            TF_VAR_system_dns_zone_name: {{system_dns_zone_name}}
            TF_VAR_apps_dns_zone_name: {{apps_dns_zone_name}}
            AWS_DEFAULT_REGION: {{aws_region}}
          run:
            path: sh
            args:
              - -e
              - -c
              - |
                . terraform-variables/vpc.tfvars.sh
                . terraform-variables/concourse.tfvars.sh
                . terraform-variables/bosh.tfvars.sh
                . terraform-variables/cf-certs.tfvars.sh
                . terraform-variables/cf-secrets.tfvars.sh

                . pingdom-probes-ips/pingdom-probes-ips.sh

                mkdir generated-certificates
                tar xzf cf-certs/cf-certs.tar.gz -C generated-certificates

                terraform apply -var-file=paas-cf/terraform/{{aws_account}}.tfvars \
                  -state=cf-tfstate/cf.tfstate -state-out=updated-tfstate/cf.tfstate paas-cf/terraform/cloudfoundry
        ensure:
          put: cf-tfstate
          params:
            file: updated-tfstate/cf.tfstate

      - task: extract-cf-terraform-outputs
        config:
          platform: linux
          image: docker:///ruby#2.2-slim
          inputs:
            - name: paas-cf
            - name: cf-tfstate
          outputs:
            - name: cf-terraform-outputs
          run:
            path: sh
            args:
              - -e
              - -c
              - |
                SCPATH="./paas-cf/concourse/scripts"
                SCFILE="extract_tf_vars_from_terraform_state.rb"
                $SCPATH/$SCFILE < cf-tfstate/cf.tfstate > cf-terraform-outputs/cf.tfstate.sh
                ls -l cf-terraform-outputs/cf.tfstate.sh
      - task: init-db
        config:
          platform: linux
          image: docker:///governmentpaas/psql
          inputs:
            - name: terraform-variables
            - name: paas-cf
            - name: cf-terraform-outputs
          run:
            path: sh
            args:
              - -e
              - -c
              - |
                . terraform-variables/cf-secrets.tfvars.sh
                . cf-terraform-outputs/cf.tfstate.sh

                paas-cf/manifests/cf-manifest/scripts/create-cf-dbs.sh

  - name: generate-cf-config
    serial_groups: [cf-deploy]
    serial: true
    plan:
      - aggregate:
          - get: pipeline-trigger
            passed: ['cf-terraform']
            trigger: true
          - get: paas-cf
            passed: ['cf-terraform']
          - get: bosh-CA
          - get: cf-secrets
            passed: ['cf-terraform']
          - get: cf-certs
          - get: vpc-tfstate
          - get: concourse-tfstate
          - get: bosh-tfstate
          - get: cf-tfstate
            passed: ['cf-terraform']
      - task: extract-terraform-outputs
        config:
          platform: linux
          image: docker:///ruby#2.2-slim
          inputs:
            - name: paas-cf
            - name: vpc-tfstate
            - name: bosh-tfstate
            - name: concourse-tfstate
            - name: cf-tfstate
          outputs:
            - name: terraform-outputs
          run:
            path: sh
            args:
              - -e
              - -c
              - |
                for state in vpc bosh concourse cf; do
                  ./paas-cf/concourse/scripts/extract_terraform_state_to_yaml.rb \
                    < $state-tfstate/$state.tfstate \
                    > terraform-outputs/$state.yml
                  ./paas-cf/concourse/scripts/extract_tf_vars_from_terraform_state.rb \
                    < ${state}-tfstate/${state}.tfstate \
                    > terraform-outputs/${state}.tfvars.sh
                done
      - task: generate-manifest
        config:
          platform: linux
          image: docker:///governmentpaas/spruce
          inputs:
            - name: paas-cf
            - name: terraform-outputs
            - name: cf-secrets
            - name: cf-certs
            - name: bosh-CA
          outputs:
            - name: cf-manifest
          params:
            MANIFEST_STUBS: |
              ./terraform-outputs/*.yml
              ./cf-secrets/cf-secrets.yml
              ./certs/*.yml
          run:
            path: sh
            args:
              - -e
              - -c
              - |
                mkdir certs
                echo "Extracting extant certs"
                tar -xvzf bosh-CA/bosh-CA.tar.gz -C certs
                tar -xvzf cf-certs/cf-certs.tar.gz -C certs

                cd certs
                for file in *.crt; do
                  cn=${file%.crt}
                  yaml_key_name=$(echo ${cn} | tr A-Z- a-z_)

                  echo "Converting ${cn} certs to YAML"
                  ../paas-cf/concourse/scripts/file-to-yaml.sh secrets ${yaml_key_name}_key ${cn}.key > ${cn}_key.yml
                  ../paas-cf/concourse/scripts/file-to-yaml.sh secrets ${yaml_key_name}_cert ${cn}.crt > ${cn}_cert.yml
                done

                ../paas-cf/concourse/scripts/file-to-yaml.sh secrets uaa_jwt_verification_key uaa_jwt_verification.pem > uaa_jwt_verification_key.yml
                cd ..

                echo "Generating manifests"
                ./paas-cf/manifests/cf-manifest/build_manifest.sh $MANIFEST_STUBS > cf-manifest/cf-manifest.yml
        on_success:
          put: cf-manifest
          params:
            file: cf-manifest/cf-manifest.yml

  - name: cf-deploy
    serial_groups: [cf-deploy]
    serial: true
    plan:
      - aggregate:
          - get: pipeline-trigger
            passed:
              - 'generate-cf-config'
              - 'bosh-deploy'
            trigger: true
          - get: paas-cf
            passed: ['generate-cf-config']
          - get: cf-manifest
            passed: ['generate-cf-config']
          - get: bosh-secrets
          - get: graphite-statsd-boshrelease
          - get: grafana-boshrelease
      - task: upload-releases
        config:
          platform: linux
          image: docker:///governmentpaas/bosh-cli
          inputs:
            - name: paas-cf
            - name: bosh-secrets
            - name: graphite-statsd-boshrelease
            - name: grafana-boshrelease
          run:
            path: sh
            args:
              - -e
              - -c
              - |
                ./paas-cf/concourse/scripts/bosh_login.sh bosh-secrets/bosh-secrets.yml

                paas-cf/concourse/scripts/bosh_create_and_upload_release.rb graphite \
                  {{cf_graphite_version}} graphite-statsd-boshrelease

                paas-cf/concourse/scripts/bosh_create_and_upload_release.rb grafana \
                  {{cf_grafana_version}} grafana-boshrelease

      - task: cf-deploy
        config:
          platform: linux
          image: docker:///governmentpaas/bosh-cli
          inputs:
            - name: paas-cf
            - name: cf-manifest
            - name: bosh-secrets
          outputs:
            - name: updated-cf-manifest
          run:
            path: sh
            args:
              - -e
              - -c
              - |
                ./paas-cf/concourse/scripts/bosh_login.sh bosh-secrets/bosh-secrets.yml
                sed -e "s/^director_uuid:.*/director_uuid: $(bosh status --uuid)/" < cf-manifest/cf-manifest.yml > updated-cf-manifest/cf-manifest.yml
                bosh deployment updated-cf-manifest/cf-manifest.yml
                bosh -n deploy
      - put: cf-manifest
        params:
          file: updated-cf-manifest/cf-manifest.yml

  - name: post-deploy
    plan:
    - aggregate:
        - get: pipeline-trigger
          passed: [ 'cf-deploy']
          trigger: true
        - get: paas-cf
          passed: ['cf-deploy']
        - get: cf-secrets
          passed: ['generate-cf-config']
        - get: cf-manifest
          passed: ['cf-deploy']
        - get: bosh-CA
        - get: graphite-nozzle
    - task: retrieve-config
      config:
        platform: linux
        inputs:
          - name: paas-cf
          - name: cf-secrets
          - name: cf-manifest
        outputs:
          - name: config
        params:
        image: docker:///ruby#2.2-slim
        run:
          path: sh
          args:
            - -e
            - -c
            - |
              VAL_FROM_YAML=$(pwd)/paas-cf/concourse/scripts/val_from_yaml.rb

              CF_ADMIN=admin
              CF_PASS=$($VAL_FROM_YAML secrets.uaa_admin_password cf-secrets/cf-secrets.yml)
              FIREHOSE_USER=graphite-nozzle
              FIREHOSE_PASS=$($VAL_FROM_YAML secrets.uaa_clients_firehose_password cf-secrets/cf-secrets.yml)
              API_ENDPOINT=$($VAL_FROM_YAML properties.cc.srv_api_uri cf-manifest/cf-manifest.yml)
              UAA_ENDPOINT=$($VAL_FROM_YAML properties.uaa.url cf-manifest/cf-manifest.yml)
              DOPPLER_ENDPOINT=$($VAL_FROM_YAML properties.loggregator.traffic_controller_url cf-manifest/cf-manifest.yml)
              GRAPHITE_SERVER=$($VAL_FROM_YAML jobs.graphite_z1.networks.cf1.static_ips.0 cf-manifest/cf-manifest.yml)

              for var_name in CF_ADMIN CF_PASS FIREHOSE_USER FIREHOSE_PASS API_ENDPOINT UAA_ENDPOINT DOPPLER_ENDPOINT GRAPHITE_SERVER; do
                echo export "${var_name}"=\"$(eval echo \$${var_name})\"
              done > config/config.sh

              CF_MANIFEST=cf-manifest/cf-manifest.yml $(pwd)/paas-cf/concourse/scripts/extract_quota_settings.rb > config/quota_settings.sh

    - task: update-default-quota
      config:
        platform: linux
        inputs:
          - name: paas-cf
          - name: config
          - name: bosh-CA
        params:
        image: docker:///governmentpaas/cf-cli
        run:
          path: sh
          args:
            - -e
            - -c
            - |
              ./paas-cf/concourse/scripts/import_bosh_ca.sh

              . ./config/config.sh
              echo | cf login -a ${API_ENDPOINT} -u ${CF_ADMIN} -p ${CF_PASS}

              . ./config/quota_settings.sh
              ${QUOTA_non_basic_services_allowed} || prefix="dis"

              cf update-quota "${QUOTA_DEFAULT}" \
                -m "${QUOTA_memory_limit}"M \
                -r "${QUOTA_total_routes}" \
                -s "${QUOTA_total_services}" \
                --${prefix}allow-paid-service-plans

    - task: deploy-healthcheck-app
      config:
        platform: linux
        image: docker:///governmentpaas/cf-cli
        inputs:
          - name: paas-cf
          - name: config
          - name: bosh-CA
        run:
          path: sh
          args:
            - -e
            - -c
            - |
              ./paas-cf/concourse/scripts/import_bosh_ca.sh

              . ./config/config.sh
              echo | cf login -a ${API_ENDPOINT} -u ${CF_ADMIN} -p ${CF_PASS}
              echo | cf create-org testers
              cf create-space healthcheck -o testers
              cf target -o testers -s healthcheck

              cd paas-cf/tests/example-apps/healthcheck-app

              cf push

    - task: deploy-graphite-nozzle
      config:
        platform: linux
        inputs:
          - name: paas-cf
          - name: graphite-nozzle
          - name: config
          - name: bosh-CA
        params:
        image: docker:///governmentpaas/cf-cli
        run:
          path: sh
          args:
            - -e
            - -c
            - |
              ./paas-cf/concourse/scripts/import_bosh_ca.sh

              . ./config/config.sh
              echo | cf login -a ${API_ENDPOINT} -u ${CF_ADMIN} -p ${CF_PASS}
              echo | cf create-org admin
              cf create-space admin -o admin
              cf target -o admin -s admin

              cat <<EOF > graphite-nozzle.json
              [
                  {"protocol":"udp","destination":"${GRAPHITE_SERVER}","ports":"8125"}
              ]
              EOF
              cf create-security-group graphite-nozzle graphite-nozzle.json
              cf bind-staging-security-group graphite-nozzle
              cf bind-running-security-group graphite-nozzle

              cd graphite-nozzle

              echo "web: graphite-nozzle" > Procfile

              cat <<EOF > manifest.yml
              ---
              applications:
              - name: graphite-nozzle
                memory: 100M
                instances: 1
                no-route: true
                health-check-type: none
                env:
                  DOPPLER_ENDPOINT: "${DOPPLER_ENDPOINT}"
                  UAA_ENDPOINT: "${UAA_ENDPOINT}"
                  STATSD_ENDPOINT: "${GRAPHITE_SERVER}:8125"
                  FIREHOSE_USERNAME: "${FIREHOSE_USER}"
                  FIREHOSE_PASSWORD: "${FIREHOSE_PASS}"
                  SUBSCRIPTION_ID: "firehose"
                  STATSD_PREFIX: "cfstats."
                  SKIP_SSL_VALIDATION: "true"
                  PREFIX_JOB: "true"
              EOF

              cf push

  - name: smoke-tests
    serial_groups: [smoke-tests]
    plan:
      - aggregate:
          - get: pipeline-trigger
            passed: [ 'cf-deploy']
            trigger: true
          - get: cf-release
            params:
              submodules:
                - src/smoke-tests
          - get: paas-cf
            passed: ['cf-deploy']
          - get: cf-manifest
            passed: ['cf-deploy']
          - get: bosh-CA
      - task: smoke-tests-config
        file: paas-cf/concourse/pipelines/tasks/smoke-tests-config.yml

      - task: smoke-tests-run
        file: paas-cf/concourse/pipelines/tasks/smoke-tests-run.yml

  - name: acceptance-tests
    plan:
      - aggregate:
          - get: pipeline-trigger
            passed: [ 'cf-deploy']
            trigger: true
          - get: cf-release
            params:
              submodules:
                - src/github.com/cloudfoundry/cf-acceptance-tests
          - get: paas-cf
            passed: ['cf-deploy']
          - get: cf-manifest
            passed: ['cf-deploy']
          - get: bosh-CA

      - task: generate-test-config
        config:
          platform: linux
          image: docker:///governmentpaas/bosh-cli
          inputs:
            - name: cf-release
            - name: paas-cf
            - name: cf-manifest
          outputs:
            - name: test-config
          run:
            path: sh
            args:
              - -e
              - -c
              - |
                ./paas-cf/tests/bosh-template-renderer/render.rb \
                  ./cf-release/jobs/acceptance-tests/templates/run.erb \
                  ./cf-release/jobs/acceptance-tests/spec \
                  ./cf-manifest/cf-manifest.yml \
                    > ./test-config/run

                chmod +x ./test-config/run

                ./paas-cf/tests/bosh-template-renderer/render.rb \
                  ./cf-release/jobs/acceptance-tests/templates/config.json.erb \
                  ./cf-release/jobs/acceptance-tests/spec \
                  ./cf-manifest/cf-manifest.yml \
                    > ./test-config/config.json

      - task: run-tests
        config:
          platform: linux
          image: docker:///governmentpaas/cf-acceptance-tests
          inputs:
            - name: paas-cf
            - name: cf-release
            - name: cf-manifest
            - name: test-config
            - name: bosh-CA
          run:
            path: sh
            args:
              - -e
              - -c
              - |
                ./paas-cf/concourse/scripts/import_bosh_ca.sh

                mkdir -p /var/vcap/jobs/acceptance-tests/bin/ /var/vcap/packages/acceptance-tests/src/github.com/cloudfoundry
                ln -snf $(pwd)/test-config/config.json /var/vcap/jobs/acceptance-tests/bin/config.json
                ln -snf $(pwd)/test-config/run /var/vcap/jobs/acceptance-tests/bin/run
                ln -snf /usr/local/go /var/vcap/packages/golang1.4
                sed -i 's/bits=@"%s"/bits=@%s/' cf-release/src/github.com/cloudfoundry/cf-acceptance-tests/helpers/v3_helpers/v3.go
                ln -snf $(pwd)/cf-release/src/github.com/cloudfoundry/cf-acceptance-tests /var/vcap/packages/acceptance-tests/src/github.com/cloudfoundry/
                /var/vcap/jobs/acceptance-tests/bin/run

  - name: custom-acceptance-tests
    plan:
      - aggregate:
          - get: pipeline-trigger
            passed: ['cf-deploy']
            trigger: true
          - get: paas-cf
            passed: ['cf-deploy']
          - get: cf-manifest
            passed: ['cf-deploy']
          - get: bosh-CA
          - get: concourse-manifest
      - task: generate-test-config
        config:
          platform: linux
          image: docker:///ruby#2.2-slim
          inputs:
            - name: paas-cf
            - name: cf-manifest
          outputs:
            - name: test-config
          run:
            path: sh
            args:
              - -e
              - -c
              - |
                export CF_MANIFEST=cf-manifest/cf-manifest.yml
                ./paas-cf/tests/generate_test_config.rb \
                  > test-config/config.json
      - task: get-vm-ip-list
        config:
          platform: linux
          image: docker:///ruby#2.2-slim
          params:
            SYSTEM_DNS_ZONE_NAME: {{system_dns_zone_name}}
            DEPLOY_ENV: {{deploy_env}}
          inputs:
          - name: paas-cf
          - name: concourse-manifest
          outputs:
          - name: ip-list
          run:
            path: sh
            args:
            - -e
            - -c
            - |
              VAL_FROM_YAML=$(pwd)/paas-cf/concourse/scripts/val_from_yaml.rb
              CONCOURSE_ATC_PASSWORD=$("$VAL_FROM_YAML" jobs.concourse.properties.atc.basic_auth_password concourse-manifest/concourse-manifest.yml)
              export CONCOURSE_ATC_PASSWORD
              ./paas-cf/concourse/scripts/bosh-cli.sh bosh vms 2>&1 | awk -F'|' '{print $6}' | grep 10\. > ./ip.txt
              echo -n '{"ips": [' > ip-list/ips.json
              for ip in $(cat ./ip.txt);do echo -n \"$ip\"",";done | sed 's/.$//' >> ip-list/ips.json
              echo ']}' >> ip-list/ips.json
      - task: run-tests
        config:
          platform: linux
          image: docker:///governmentpaas/cf-acceptance-tests
          inputs:
            - name: paas-cf
            - name: ip-list
            - name: test-config
            - name: bosh-CA
          run:
            path: sh
            args:
              - -e
              - -c
              - |
                ./paas-cf/concourse/scripts/import_bosh_ca.sh

                echo "Running tests"
                export CONFIG="$(pwd)/test-config/config.json"
                IP_LIST=$(cat ip-list/ips.json) ./paas-cf/tests/run_tests.sh ./paas-cf/tests/acceptance-tests/src/acceptance/

  - name: bosh-cli-test
    plan:
      - aggregate:
          - get: pipeline-trigger
            passed: ['cf-deploy']
            trigger: true
          - get: paas-cf
            passed: ['cf-deploy']
          - get: concourse-manifest
      - task: connect-to-bosh-cli
        config:
          platform: linux
          image: docker:///ruby#2.2-slim
          params:
            SYSTEM_DNS_ZONE_NAME: {{system_dns_zone_name}}
            DEPLOY_ENV: {{deploy_env}}
          inputs:
          - name: paas-cf
          - name: concourse-manifest
          run:
            path: sh
            args:
            - -e
            - -c
            - |
              VAL_FROM_YAML=$(pwd)/paas-cf/concourse/scripts/val_from_yaml.rb
              CONCOURSE_ATC_PASSWORD=$("$VAL_FROM_YAML" jobs.concourse.properties.atc.basic_auth_password concourse-manifest/concourse-manifest.yml)
              export CONCOURSE_ATC_PASSWORD
              ./paas-cf/concourse/scripts/bosh-cli.sh bosh status

  - name: performance-tests
    plan:
      - aggregate:
          - get: pipeline-trigger
            passed: ['post-deploy', 'smoke-tests', 'acceptance-tests', 'custom-acceptance-tests', 'bosh-cli-test']
            trigger: true
          - get: paas-cf
            passed: ['post-deploy', 'smoke-tests', 'acceptance-tests', 'custom-acceptance-tests', 'bosh-cli-test']
          - get: cf-manifest
            passed: ['post-deploy', 'smoke-tests', 'acceptance-tests', 'custom-acceptance-tests']
          - get: bosh-CA
      - task: generate-test-config
        config:
          platform: linux
          image: docker:///ruby#2.2-slim
          inputs:
            - name: paas-cf
            - name: cf-manifest
          outputs:
            - name: test-config
          run:
            path: sh
            args:
              - -e
              - -c
              - |
                export CF_MANIFEST=cf-manifest/cf-manifest.yml
                ./paas-cf/tests/generate_test_config.rb \
                  > test-config/config.json

      - task: run-tests
        config:
          platform: linux
          image: docker:///governmentpaas/cf-acceptance-tests
          inputs:
            - name: paas-cf
            - name: test-config
            - name: bosh-CA
          outputs:
            - name: tests-results
          run:
            path: sh
            args:
              - -e
              - -c
              - |
                ./paas-cf/concourse/scripts/import_bosh_ca.sh

                echo "Running tests"
                export CONFIG="$(pwd)/test-config/config.json"
                ./paas-cf/tests/run_tests.sh ./paas-cf/tests/performance-tests/src/performance/

  - name: tag-release
    plan:
      - aggregate:
          - get: pipeline-trigger
            passed: ['performance-tests']
            trigger: true
          - get: paas-cf
            passed: ['performance-tests']
          - get: git-keys

      - put: release-version
        params: {bump: patch}

      - task: tag-release
        config:
          image: docker:///governmentpaas/git-ssh
          platform: linux
          params:
            aws_account: {{aws_account}}
            deploy_env: {{deploy_env}}
            TAG_PREFIX: {{TAG_PREFIX}}
            TAG_FILTER: {{paas_cf_tag_filter}}
          inputs:
          - name: paas-cf
          - name: release-version
          - name: git-keys
          run:
            path: sh
            args:
            - -e
            - -c
            - |
              if [ -z "${TAG_PREFIX}" ]; then
                echo \$TAG_PREFIX not set, skipping
                exit 0
              fi
              paas-cf/concourse/scripts/tag-release.sh \
                ${TAG_PREFIX} ${aws_account} ${deploy_env} ${TAG_FILTER}

  - name: pipeline-unlock
    serial: true
    plan:
      - get: pipeline-trigger
        passed: ['tag-release']
        trigger: true
      - get: pipeline-pool
      - put: pipeline-pool
        params:
          release: pipeline-pool

  - name: pipeline-check-lock
    plan:
      - get: pipeline-pool
      - task: print-pipeline-lock-state
        config:
          image: docker:///governmentpaas/git-ssh
          platform: linux
          inputs:
          - name: pipeline-pool
          run:
            path: sh
            args:
            - -e
            - -c
            - |
              if [ -f pipeline-pool/{{pipeline_name}}/claimed/lock ]; then
                current_status_message="LOCKED"
              elif [ -f pipeline-pool/{{pipeline_name}}/unclaimed/lock ]; then
                current_status_message="UNLOCKED"
              else
                echo "Error: Cannot find lock in pool: pipeline-pool/{{pipeline_name}}/{un,}claimed/lock"
                exit 1
              fi

              cd pipeline-pool
              export GIT_PAGER="cat"
              git log -1 --pretty=format:"
              Lock status is: ${current_status_message}

              Last commit change:
               - %cr at %ci
               - %s
              "

  - name: pipeline-release-lock
    plan:
      - get: pipeline-pool
      - put: pipeline-pool
        params:
          release: pipeline-pool

  - name: generate-git-keys
    plan:
      - task: ssh-keygen
        config:
          image: docker:///governmentpaas/git-ssh
          platform: linux
          outputs:
          - name: generated-git-keys
          run:
            path: sh
            args:
            - -e
            - -c
            - |
              ssh-keygen -t rsa -b 4096 -f git-key -N ''
              tar -cvzf generated-git-keys/git-keys.tar.gz ./git-key ./git-key.pub
              cat ./git-key.pub
        on_success:
          put: git-keys
          params:
            file: generated-git-keys/git-keys.tar.gz

  - name: bump-major-version
    plan:
      - put: release-version
        params: {bump: major}

  - name: bump-minor-version
    plan:
      - put: release-version
        params: {bump: minor}

  - name: bump-patch-version
    plan:
      - put: release-version
        params: {bump: patch}

  - name: show-release-version
    plan:
      - get: release-version

      - task: show-release-version
        config:
          platform: linux
          inputs:
            - name: release-version
          run:
            path: cat
            args:
            - release-version/number

  - name: continuous-smoke-tests
    serial_groups: [smoke-tests]
    plan:
      - get: cf-release
        params:
          submodules:
            - src/smoke-tests
      - get: paas-cf
        passed: ['cf-deploy']
      - get: cf-manifest
        passed: ['cf-deploy']
      - get: bosh-CA
      - get: smoke-tests-timer
        trigger: {{continuous_smoke_tests_trigger}}

      - task: smoke-tests-config
        file: paas-cf/concourse/pipelines/tasks/smoke-tests-config.yml

      - task: smoke-tests-run
        file: paas-cf/concourse/pipelines/tasks/smoke-tests-run.yml
        on_failure:
          task: alert
          config:
            platform: linux
            image: docker:///governmentpaas/awscli
            params:
              AWS_DEFAULT_REGION: {{aws_region}}
              DEPLOY_ENV: {{deploy_env}}
              SYSTEM_DNS_ZONE_NAME: {{system_dns_zone_name}}
              ALERT_EMAIL_ADDRESS: {{ALERT_EMAIL_ADDRESS}}
            inputs:
              - name: paas-cf
              - name: smoke-tests-log
            run:
              path: sh
              args:
              - -e
              - -c
              - |
                paas-cf/concourse/scripts/smoke_tests_email.sh \
                  ${DEPLOY_ENV} ${SYSTEM_DNS_ZONE_NAME} ${ALERT_EMAIL_ADDRESS}
