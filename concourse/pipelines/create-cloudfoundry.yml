---
meta:
  containers:
    awscli: &awscli-image-resource
      type: docker-image
      source:
        repository: governmentpaas/awscli
        tag: b2495d6ed07f680125d19aa7d1701da7efabb289
    bosh-cli-v2: &gov-paas-bosh-cli-v2-image-resource
      type: docker-image
      source:
        repository: governmentpaas/bosh-cli-v2
        tag: 4012d25ceb903b46908a830b8e05773ced1c8f86
    cf-acceptance-tests: &cf-acceptance-tests-image-resource
      type: docker-image
      source:
        repository: governmentpaas/cf-acceptance-tests
        tag: 51c4648c56a18e28a295e73963b65fdbfe76e52f
    cf-cli: &cf-cli-image-resource
      type: docker-image
      source:
        repository: governmentpaas/cf-cli
        tag: 51c4648c56a18e28a295e73963b65fdbfe76e52f
    git-ssh: &git-ssh-image-resource
      type: docker-image
      source:
        repository: governmentpaas/git-ssh
        tag: 465642da06051a55630d39c899697b678f66a7f7
    ruby-slim: &ruby-slim-image-resource
      type: docker-image
      source:
        repository: ruby
        tag: 2.5-slim
    terraform: &terraform-image-resource
      type: docker-image
      source:
        repository: governmentpaas/terraform
        tag: f810666094e6c65eeb183f9833b231aa24df6811

groups:
  - name: deploy
    jobs:
      - pipeline-lock
      - pre-deploy
      - generate-secrets
      - app-availability-tests
      - api-availability-tests
      - cf-terraform
      - generate-cf-config
      - cf-deploy
      - prometheus-deploy
      - post-deploy
      - smoke-tests
      - acceptance-tests
      - log-cache-acceptance-tests
      - custom-acceptance-tests
      - bosh-tests
      - performance-tests
      - tag-release
      - pipeline-unlock
  - name: operator
    jobs:
      - generate-git-keys
      - show-release-version
      - bump-minor-version
      - bump-major-version
      - bump-patch-version
      - pipeline-check-lock
      - pipeline-release-lock
  - name: tests
    jobs:
      - app-availability-tests
      - api-availability-tests
      - smoke-tests
      - acceptance-tests
      - log-cache-acceptance-tests
      - custom-acceptance-tests
      - bosh-tests
      - performance-tests
  - name: health
    jobs:
      - continuous-smoke-tests
      - check-certificates
      - health-snapshot
  - name: credentials
    jobs:
      - rotate-cf-admin-password
      - rotate-cloudfoundry-credentials
      - expire-aws-keys
      - rotate-cf-certs-cas
      - rotate-cf-certs-leafs
      - delete-old-cf-certs
resource_types:
- name: s3-iam
  type: docker-image
  source:
    repository: governmentpaas/s3-resource
    tag: fda60bf4c5f85e96c16f704e128e5ead9e84d30d

- name: semver-iam
  type: docker-image
  source:
    repository: governmentpaas/semver-resource
    tag: ecbdd201e122b44de99a40ac9f24407c1a43b9a2

resources:
  - name: pipeline-trigger
    type: semver-iam
    source:
      bucket: ((state_bucket))
      region_name: ((aws_region))
      key: ((pipeline_trigger_file))

  - name: paas-cf
    type: git
    source:
      uri: https://github.com/alphagov/paas-cf.git
      branch: ((branch_name))
      tag_filter: ((paas_cf_tag_filter))
      commit_verification_keys: ((gpg_public_keys))

  - name: vpc-tfstate
    type: s3-iam
    source:
      bucket: ((state_bucket))
      region_name: ((aws_region))
      versioned_file: vpc.tfstate

  - name: concourse-tfstate
    type: s3-iam
    source:
      bucket: ((state_bucket))
      versioned_file: concourse.tfstate
      region_name: ((aws_region))

  - name: bosh-tfstate
    type: s3-iam
    source:
      bucket: ((state_bucket))
      region_name: ((aws_region))
      versioned_file: bosh.tfstate

  - name: bosh-secrets
    type: s3-iam
    source:
      bucket: ((state_bucket))
      region_name: ((aws_region))
      versioned_file: bosh-secrets.yml

  - name: bosh-CA-crt
    type: s3-iam
    source:
      bucket: ((state_bucket))
      region_name: ((aws_region))
      versioned_file: bosh-CA.crt

  - name: ipsec-CA
    type: s3-iam
    source:
      bucket: ((state_bucket))
      region_name: ((aws_region))
      versioned_file: ipsec-CA.tar.gz
      initial_version: "-"
      # This is an empty tar.gz file base64 encoded
      initial_content_binary: "H4sICMtSp1YAA2NvbmNvdXJzZS1jZXJ0cy50YXIA7cEBDQAAAMKg909tDjegAAAAAAAAAAAAgDcDmt4dJwAoAAA="

  - name: ssh-private-key
    type: s3-iam
    source:
      bucket: ((state_bucket))
      versioned_file: id_rsa
      region_name: ((aws_region))
      initial_version: "-"

  - name: ssh-public-key
    type: s3-iam
    source:
      bucket: ((state_bucket))
      versioned_file: id_rsa.pub
      region_name: ((aws_region))
      initial_version: "-"

  - name: git-ssh-private-key
    type: s3-iam
    source:
      bucket: ((state_bucket))
      versioned_file: git_id_rsa
      region_name: ((aws_region))

  - name: cf-tfstate
    type: s3-iam
    source:
      bucket: ((state_bucket))
      versioned_file: cf.tfstate
      region_name: ((aws_region))
      initial_version: "-"
      initial_content_text: |
        {
            "version": 3,
            "terraform_version": "0.11.1",
            "serial": 0,
            "modules": [
                {
                    "path": [
                        "root"
                    ],
                    "outputs": {},
                    "resources": {},
                    "depends_on": []
                }
            ]
        }

  - name: datadog-tfstate
    type: s3-iam
    source:
      bucket: ((state_bucket))
      versioned_file: datadog.tfstate
      region_name: ((aws_region))
      initial_version: "-"
      initial_content_text: |
        {
            "version": 3,
            "terraform_version": "0.11.1",
            "serial": 0,
            "modules": [
                {
                    "path": [
                        "root"
                    ],
                    "outputs": {},
                    "resources": {},
                    "depends_on": []
                }
            ]
        }

  - name: cf-secrets
    type: s3-iam
    source:
      bucket: ((state_bucket))
      region_name: ((aws_region))
      versioned_file: cf-secrets.yml
      initial_version: "-"

  - name: cf-vars-store
    type: s3-iam
    source:
      bucket: ((state_bucket))
      region_name: ((aws_region))
      versioned_file: cf-vars-store.yml
      initial_version: "-"

  - name: cf-manifest
    type: s3-iam
    source:
      bucket: ((state_bucket))
      region_name: ((aws_region))
      versioned_file: cf-manifest.yml

  - name: cf-manifest-pre-vars
    type: s3-iam
    source:
      bucket: ((state_bucket))
      region_name: ((aws_region))
      versioned_file: cf-manifest-pre-vars.yml

  - name: logit-secrets
    type: s3-iam
    source:
      bucket: ((state_bucket))
      region_name: ((aws_region))
      versioned_file: logit-secrets.yml
      initial_version: "-"
      initial_content_text: ""

  - name: cloud-config
    type: s3-iam
    source:
      bucket: ((state_bucket))
      region_name: ((aws_region))
      versioned_file: cloud-config.yml

  - name: health-snapshot-data
    type: s3-iam
    source:
      bucket: ((state_bucket))
      region_name: ((aws_region))
      versioned_file: health-snapshot-data.json
      initial_version: "-"
      initial_content_text: "{}"

  - name: health-snapshot-secrets
    type: s3-iam
    source:
      bucket: ((state_bucket))
      region_name: ((aws_region))
      versioned_file: health-snapshot-secrets.yml
      initial_version: "-"
      initial_content_text: ""

  - name: deployed-healthcheck
    type: s3-iam
    source:
      bucket: ((state_bucket))
      region_name: ((aws_region))
      versioned_file: healthcheck-deployed
      initial_version: "-"
      initial_content_text: "no"

  - name: cf-acceptance-tests
    type: git
    source:
      uri: https://github.com/cloudfoundry/cf-acceptance-tests
      branch: cf4.5

  - name: cf-smoke-tests-release
    type: git
    source:
      uri: https://github.com/cloudfoundry/cf-smoke-tests-release
      tag_filter: "40.0.9"
      submodules:
      - "src/smoke_tests"

  - name: git-keys
    type: s3-iam
    source:
      bucket: ((state_bucket))
      region_name: ((aws_region))
      versioned_file: git-keys.tar.gz
      initial_version: "-"
      # This is an empty tar.gz file base64 encoded
      initial_content_binary: "H4sICMtSp1YAA2NvbmNvdXJzZS1jZXJ0cy50YXIA7cEBDQAAAMKg909tDjegAAAAAAAAAAAAgDcDmt4dJwAoAAA="

  - name: release-version
    type: semver-iam
    source:
      bucket: ((state_bucket))
      region_name: ((aws_region))
      key: release-version
      initial_version: 0.0.0

  - name: pipeline-pool
    type: pool
    source:
      uri: ((git_concourse_pool_clone_full_url_ssh))
      branch: master
      pool: ((pipeline_name))
      private_key: ((pipeline_lock_git_private_key))

  - name: smoke-tests-timer
    type: time
    source:
      interval: 5m

  - name: check-certificates-timer
    type: time
    source:
      interval: 24h

  - name: expire-aws-keys-timer
    type: time
    source:
      interval: 720h

  - name: health-snapshot-timer
    type: time
    source:
      interval: 5m

  - name: paas-aiven-broker
    type: git
    source:
      uri: https://github.com/alphagov/paas-aiven-broker
      tag_filter: v0.10.0

  - name: paas-billing
    type: git
    source:
      uri: https://github.com/alphagov/paas-billing
      tag_filter: v0.44.0

  - name: paas-accounts
    type: git
    source:
      uri: https://github.com/alphagov/paas-accounts
      tag_filter: v0.1.0

  - name: paas-admin
    type: git
    source:
      uri: https://github.com/alphagov/paas-admin
      tag_filter: v0.43.0

  - name: paas-log-cache-adapter
    type: git
    source:
      uri: https://github.com/alphagov/paas-log-cache-adapter
      tag_filter: v0.6.0

  - name: prometheus-vars-store
    type: s3-iam
    source:
      bucket: ((state_bucket))
      region_name: ((aws_region))
      versioned_file: prometheus-vars-store.yml
      initial_version: "-"

jobs:
  - name: pipeline-lock
    serial: true
    plan:
      - aggregate:
        - get: paas-cf
          trigger: ((auto_deploy))
        - get: git-ssh-private-key
      - task: init-pipeline-pool
        config:
          platform: linux
          image_resource: *git-ssh-image-resource
          inputs:
            - name: paas-cf
            - name: git-ssh-private-key
          params:
            DEPLOY_ENV: ((deploy_env))
            AWS_ACCOUNT: ((aws_account))
            DISABLE_PIPELINE_LOCKING: ((disable_pipeline_locking))
          run:
            path: sh
            args:
            - -e
            - -c
            - |
              if [ "${DISABLE_PIPELINE_LOCKING:-}" = "true" ] ; then
                 echo "Pipeline locking is disabled, skipping..."
                 exit 0
              fi
              chmod 600 git-ssh-private-key/git_id_rsa
              git config --global push.default simple
              git config --global user.email "concourse@${DEPLOY_ENV}.${AWS_ACCOUNT}"
              git config --global user.name "Concourse server ${DEPLOY_ENV} in ${AWS_ACCOUNT}"

              ./paas-cf/concourse/scripts/create_pool_lock.sh \
                "((git_concourse_pool_clone_full_url_ssh))" \
                "$(pwd)/git-ssh-private-key/git_id_rsa" \
                "((pipeline_name))" lock

      - try:
          task: lock-the-pipeline
          config:
            image_resource:
              type: docker-image
              source:
                repository: alpine
                tag: 3.7
            platform: linux
            params:
              DISABLE_PIPELINE_LOCKING: ((disable_pipeline_locking))
            run:
              path: sh
              args:
              - -e
              - -c
              - |
                if [ "${DISABLE_PIPELINE_LOCKING:-}" = "true" ] ; then
                   echo "Pipeline locking is disabled, skipping..."
                   exit 0
                fi
                echo "About to lock. This job will fail and this is OK."
                exit 1
          on_failure:
            put: pipeline-pool
            params:
              claim: lock

      - task: self-update-pipeline
        config:
          platform: linux
          image_resource:
            type: docker-image
            source:
              repository: governmentpaas/self-update-pipelines
              tag: 0eff5b6a9c092f865a2b19cc4e75a3b539b82fa2
          inputs:
            - name: paas-cf
          params:
            DEPLOY_ENV: ((deploy_env))
            BRANCH: ((branch_name))
            MAKEFILE_ENV_TARGET: ((makefile_env_target))
            AWS_DEFAULT_REGION: ((aws_region))
            SELF_UPDATE_PIPELINE: ((self_update_pipeline))
            PIPELINES_TO_UPDATE: ((pipeline_name))
            BOSH_AZ: ((bosh_az))
            SKIP_AWS_CREDENTIAL_VALIDATION: true
            ENABLE_DATADOG: ((enable_datadog))
            NEW_ACCOUNT_EMAIL_ADDRESS: ((NEW_ACCOUNT_EMAIL_ADDRESS))
            SLIM_DEV_DEPLOYMENT: ((slim_dev_deployment))
          run:
            path: ./paas-cf/concourse/scripts/self-update-pipeline.sh
      - put: pipeline-trigger
        params: {bump: patch}

  - name: generate-secrets
    serial_groups: [cf-deploy]
    serial: true
    plan:
      - aggregate:
          - get: paas-cf
            passed: ['pipeline-lock']
          - get: pipeline-trigger
            passed: ['pipeline-lock']
            trigger: true
          - get: ipsec-CA
          - get: cf-secrets
          - get: ssh-private-key
          - get: ssh-public-key
      - aggregate:
        - task: generate-ipsec-CA
          config:
            platform: linux
            image_resource:
              type: docker-image
              source:
                repository: governmentpaas/certstrap
                tag: 465642da06051a55630d39c899697b678f66a7f7
            inputs:
              - name: paas-cf
              - name: ipsec-CA
                path: existing-ipsec-CA
            outputs:
              - name: generated-ipsec-CA
            run:
              path: sh
              args:
                - -e
                - -c
                - |
                  if  [ -z "$(tar -tvzf existing-ipsec-CA/ipsec-CA.tar.gz)" ] ; then
                    certstrap init --years "10" --passphrase "" --common-name ipsec-CA
                    (cd out && tar -cvzf ../generated-ipsec-CA/ipsec-CA.tar.gz ipsec-CA.*)
                  else
                    echo "The CA cert already exists, skipping generation..."
                    cp existing-ipsec-CA/ipsec-CA.tar.gz generated-ipsec-CA/ipsec-CA.tar.gz
                    mkdir out
                    tar -xvzf generated-ipsec-CA/ipsec-CA.tar.gz -C out
                  fi
          on_success:
            put: ipsec-CA
            params:
              file: generated-ipsec-CA/ipsec-CA.tar.gz

        - task: generate-deployments-ssh-keypair
          config:
            platform: linux
            image_resource: *git-ssh-image-resource
            inputs:
              - name: paas-cf
              - name: ssh-private-key
              - name: ssh-public-key
            outputs:
              - name: generated-ssh-private-key
              - name: generated-ssh-public-key
            run:
              path: sh
              args:
                - -e
                - -c
                - |
                  if [ -s ssh-private-key/id_rsa ] ; then
                    echo "Deployments private key non-zero size, skipping generation..."
                    echo "Key uploads will fail and this is OK as no new keys have been generated."
                    exit 0
                  fi

                  echo "Generating new ssh key pair for deployments..."
                  ssh-keygen -t rsa -b 4096 -f id_rsa -N ''
                  cp id_rsa generated-ssh-private-key
                  cp id_rsa.pub generated-ssh-public-key
          on_success:
            try:
              aggregate:
                - put: ssh-private-key
                  params:
                    file: generated-ssh-private-key/id_rsa
                - put: ssh-public-key
                  params:
                    file: generated-ssh-public-key/id_rsa.pub

      - task: generate-cf-secrets
        config:
          platform: linux
          image_resource: *ruby-slim-image-resource
          inputs:
            - name: paas-cf
            - name: cf-secrets
          outputs:
            - name: generated-cf-secrets
          run:
            path: sh
            args:
              - -c
              - -e
              - |
                ./paas-cf/manifests/cf-manifest/scripts/generate-cf-secrets.rb \
                  --existing-secrets cf-secrets/cf-secrets.yml \
                  > generated-cf-secrets/cf-secrets.yml
                ls -l generated-cf-secrets
        on_success:
          put: cf-secrets
          params:
            file: generated-cf-secrets/cf-secrets.yml

  - name: pre-deploy
    plan:
      - aggregate:
          - get: pipeline-trigger
            passed: ['generate-secrets']
            trigger: true
          - get: deployed-healthcheck
          - get: paas-cf
            passed: ['generate-secrets']
          - get: cf-vars-store
      - task: wait-for-app-availability-tests
        config:
          platform: linux
          inputs:
            - name: paas-cf
            - name: cf-vars-store
            - name: deployed-healthcheck
            - name: pipeline-trigger
          params:
            SYSTEM_DNS_ZONE_NAME: ((system_dns_zone_name))
            CF_ADMIN: admin
          image_resource: *cf-cli-image-resource
          run:
            path: sh
            args:
              - -e
              - -u
              - -c
              - |
                HEALTHCHECK_DEPLOYED=$(cat deployed-healthcheck/healthcheck-deployed)
                if [ "${HEALTHCHECK_DEPLOYED}" = "no" ]; then
                  echo "Skipping wait-for-app-availability-tests because the healthcheck is not deployed"
                  exit 0
                fi

                CF_PASS=$(awk '/cf_admin_password/ {print $2}' cf-vars-store/cf-vars-store.yml | tr -d '"')
                API_ENDPOINT="https://api.${SYSTEM_DNS_ZONE_NAME}"
                PIPELINE_TRIGGER_VERSION=$(cat pipeline-trigger/number)

                echo | cf login -a "${API_ENDPOINT}" -u "${CF_ADMIN}" -p "${CF_PASS}" > /dev/null
                cf target -o admin -s healthchecks > /dev/null

                echo "Waiting for ~2mins for app-availability-tests job to start:"
                for _ in $(seq 24); do
                  if cf logs healthcheck --recent | grep -q "availability-test=${PIPELINE_TRIGGER_VERSION}"; then
                    echo "Request detected"
                    exit 0
                  fi
                  printf "."
                  sleep 5
                done

                echo "timeout waiting for app-availability-tests job to start"
                exit 1
      - task: wait-for-api-availability-tests
        config:
          platform: linux
          inputs:
            - name: paas-cf
            - name: deployed-healthcheck
            - name: pipeline-trigger
          params:
            AWS_DEFAULT_REGION: ((aws_region))
          image_resource: *awscli-image-resource
          run:
            path: sh
            args:
              - -e
              - -c
              - |
                HEALTHCHECK_DEPLOYED=$(cat deployed-healthcheck/healthcheck-deployed)
                if [ "${HEALTHCHECK_DEPLOYED}" = "no" ]; then
                  echo "Skipping wait-for-api-availability-tests because the healthcheck is not deployed"
                  exit 0
                fi

                PIPELINE_TRIGGER_VERSION=$(cat pipeline-trigger/number)
                JOB_FILE="jobs/${PIPELINE_TRIGGER_VERSION}/api-availability-tests"
                bucket=((state_bucket))

                echo "Waiting for ~2mins for api-availability-tests job to start by polling for ${bucket}/${JOB_FILE}"
                for _ in $(seq 24); do
                  if aws s3 ls "s3://${bucket}/${JOB_FILE}" ; then
                    echo "$JOB_FILE detected"
                    exit 0
                  fi
                  printf "."
                  sleep 5
                done

                echo "timeout waiting for api-availability-tests job to start"
                exit 1

  - name: app-availability-tests
    serial: true
    plan:
      - aggregate:
          - get: pipeline-trigger
            passed: ['generate-secrets']
            trigger: true
          - get: deployed-healthcheck
          - get: paas-cf
            passed: ['generate-secrets']
      - task: run-tests
        config:
          platform: linux
          image_resource: *cf-acceptance-tests-image-resource
          inputs:
            - name: paas-cf
            - name: pipeline-trigger
            - name: deployed-healthcheck
          params:
            SKIP_SSL_VALIDATION: true
            APPS_DNS_ZONE_NAME: ((apps_dns_zone_name))
            SYSTEM_DNS_ZONE_NAME: ((system_dns_zone_name))
            CONCOURSE_ATC_USERNAME: admin
            DEPLOY_ENV: ((deploy_env))
            BRANCH: ((branch_name))
            CONCOURSE_ATC_PASSWORD: ((concourse_atc_password))
            SLIM_DEV_DEPLOYMENT: ((slim_dev_deployment))
          run:
            path: sh
            args:
              - -e
              - -c
              - |
                HEALTHCHECK_DEPLOYED=$(cat deployed-healthcheck/healthcheck-deployed)
                if [ "${HEALTHCHECK_DEPLOYED}" = "no" ]; then
                  echo "Skipping app-availability-tests because the healthcheck is not deployed"
                  exit 0
                fi

                export CONCOURSE_ATC_URL
                CONCOURSE_ATC_URL=https://deployer.${SYSTEM_DNS_ZONE_NAME}
                export PIPELINE_TRIGGER_VERSION
                PIPELINE_TRIGGER_VERSION=$(cat pipeline-trigger/number)

                if [ "${SLIM_DEV_DEPLOYMENT}" = "true" ]; then
                  echo "Running app-availability-tests but ignoring failures"
                  ./paas-cf/platform-tests/run_tests.sh ./paas-cf/platform-tests/src/platform/availability/app || true
                else
                  echo "Running app-availability-tests"
                  ./paas-cf/platform-tests/run_tests.sh ./paas-cf/platform-tests/src/platform/availability/app
                fi

  - name: api-availability-tests
    serial: true
    plan:
      - aggregate:
          - get: pipeline-trigger
            passed: ['generate-secrets']
            trigger: true
          - get: deployed-healthcheck
          - get: cf-vars-store
          - get: paas-cf
            passed: ['generate-secrets']

      - task: upload-job-file
        config:
          platform: linux
          image_resource: *awscli-image-resource
          inputs:
            - name: pipeline-trigger
            - name: deployed-healthcheck
          run:
            path: sh
            args:
              - -e
              - -c
              - |
                HEALTHCHECK_DEPLOYED=$(cat deployed-healthcheck/healthcheck-deployed)
                if [ "${HEALTHCHECK_DEPLOYED}" = "no" ]; then
                  echo "Skipping api-availability-tests because the healthcheck is not deployed"
                  exit 0
                fi

                PIPELINE_TRIGGER_VERSION=$(cat pipeline-trigger/number)
                JOB_FILE="jobs/${PIPELINE_TRIGGER_VERSION}/api-availability-tests"
                echo "Writing $JOB_FILE to S3 to signal job start"
                echo 'started' | aws s3 cp - "s3://((state_bucket))/$JOB_FILE"

      - task: run-tests
        config:
          platform: linux
          image_resource: *cf-acceptance-tests-image-resource
          inputs:
            - name: paas-cf
            - name: pipeline-trigger
            - name: deployed-healthcheck
            - name: cf-vars-store
          params:
            SKIP_SSL_VALIDATION: true
            APPS_DNS_ZONE_NAME: ((apps_dns_zone_name))
            SYSTEM_DNS_ZONE_NAME: ((system_dns_zone_name))
            CONCOURSE_ATC_USERNAME: admin
            DEPLOY_ENV: ((deploy_env))
            BRANCH: ((branch_name))
            CONCOURSE_ATC_PASSWORD: ((concourse_atc_password))
            AWS_DEFAULT_REGION: ((aws_region))
            SLIM_DEV_DEPLOYMENT: ((slim_dev_deployment))
          run:
            path: sh
            args:
              - -e
              - -c
              - |
                HEALTHCHECK_DEPLOYED=$(cat deployed-healthcheck/healthcheck-deployed)
                if [ "${HEALTHCHECK_DEPLOYED}" = "no" ]; then
                  echo "Skipping api-availability-tests because the healthcheck is not deployed"
                  exit 0
                fi

                export CONCOURSE_ATC_URL="https://deployer.${SYSTEM_DNS_ZONE_NAME}"
                export CF_USER="admin"
                export CF_PASS
                CF_PASS=$(awk '/cf_admin_password/ {print $2}' cf-vars-store/cf-vars-store.yml | tr -d '"')
                export PIPELINE_TRIGGER_VERSION
                PIPELINE_TRIGGER_VERSION=$(cat pipeline-trigger/number)
                export API_ENDPOINT="https://api.${SYSTEM_DNS_ZONE_NAME}"

                cf login -a "${API_ENDPOINT}" -u "${CF_USER}" -p "${CF_PASS}" -o admin -s healthchecks

                if [ "${SLIM_DEV_DEPLOYMENT}" = "true" ]; then
                  echo "Running api-availability-tests but ignoring failures"
                  ./paas-cf/platform-tests/run_tests.sh ./paas-cf/platform-tests/src/platform/availability/api || true
                else
                  echo "Running api-availability-tests"
                  ./paas-cf/platform-tests/run_tests.sh ./paas-cf/platform-tests/src/platform/availability/api
                fi
        ensure:
          task: delete-job-file
          config:
            platform: linux
            image_resource: *awscli-image-resource
            inputs:
              - name: pipeline-trigger
            run:
              path: sh
              args:
                - -e
                - -c
                - |
                  PIPELINE_TRIGGER_VERSION=$(cat pipeline-trigger/number)
                  JOB_FILE="jobs/${PIPELINE_TRIGGER_VERSION}/api-availability-tests"
                  aws s3 rm "s3://((state_bucket))/${JOB_FILE}"

  - name: cf-terraform
    serial_groups: [cf-deploy]
    serial: true
    plan:
      - aggregate:
          - get: paas-cf
            passed: ['pre-deploy']
          - get: pipeline-trigger
            passed: ['pre-deploy']
            trigger: true
          - get: vpc-tfstate
          - get: concourse-tfstate
          - get: cf-tfstate
          - get: cf-secrets
            passed: ['generate-secrets']

      - task: extract-terraform-variables
        config:
          platform: linux
          image_resource: *ruby-slim-image-resource
          inputs:
            - name: paas-cf
            - name: vpc-tfstate
            - name: concourse-tfstate
            - name: cf-secrets
          outputs:
            - name: terraform-variables
          run:
            path: sh
            args:
              - -e
              - -c
              - |
                ruby paas-cf/concourse/scripts/extract_tf_vars_from_terraform_state.rb \
                < vpc-tfstate/vpc.tfstate > terraform-variables/vpc.tfvars.sh
                ruby paas-cf/concourse/scripts/extract_tf_vars_from_terraform_state.rb \
                < concourse-tfstate/concourse.tfstate > terraform-variables/concourse.tfvars.sh
                ruby paas-cf/concourse/scripts/extract_tf_vars_from_yaml.rb \
                < cf-secrets/cf-secrets.yml > terraform-variables/cf-secrets.tfvars.sh

      - task: generate-peer-tfvars
        config:
          platform: linux
          image_resource: *ruby-slim-image-resource
          inputs:
            - name: paas-cf
          outputs:
            - name: vpc-peering-tfvars
          run:
            path: sh
            args:
              - -e
              - -c
              - |
                ruby paas-cf/terraform/scripts/generate_vpc_peering_tfvars.rb "paas-cf/terraform/((deploy_env)).vpc_peering.json" \
                > vpc-peering-tfvars/vpc-peers.tfvars

                cat vpc-peering-tfvars/vpc-peers.tfvars

      - task: terraform-apply
        config:
          platform: linux
          image_resource: *terraform-image-resource
          inputs:
            - name: terraform-variables
            - name: paas-cf
            - name: cf-tfstate
            - name: vpc-peering-tfvars
          outputs:
            - name: updated-tfstate
          params:
            TF_VAR_env: ((deploy_env))
            TF_VAR_system_dns_zone_name: ((system_dns_zone_name))
            TF_VAR_apps_dns_zone_name: ((apps_dns_zone_name))
            AWS_DEFAULT_REGION: ((aws_region))
          run:
            path: sh
            args:
              - -e
              - -c
              - |
                . terraform-variables/vpc.tfvars.sh
                . terraform-variables/concourse.tfvars.sh
                . terraform-variables/cf-secrets.tfvars.sh

                cp cf-tfstate/cf.tfstate updated-tfstate/cf.tfstate
                terraform init paas-cf/terraform/cloudfoundry
                terraform apply \
                  -auto-approve=true \
                  -var-file="paas-cf/terraform/((aws_account)).tfvars" \
                  -var-file="paas-cf/terraform/((aws_region)).tfvars" \
                  -var-file=vpc-peering-tfvars/vpc-peers.tfvars \
                  -state=updated-tfstate/cf.tfstate \
                  paas-cf/terraform/cloudfoundry
        ensure:
          put: cf-tfstate
          params:
            file: updated-tfstate/cf.tfstate

      # FIXME: Move this operation to Terraform when this feature is added:
      # https://github.com/terraform-providers/terraform-provider-aws/issues/113
      - task: add-aws-users-to-groups
        config:
          platform: linux
          image_resource: *awscli-image-resource
          params:
            DEPLOY_ENV: ((deploy_env))
          run:
            path: sh
            args:
            - -e
            - -c
            - |
              aws iam add-user-to-group --user-name "ses-smtp-${DEPLOY_ENV}" --group-name email-senders
              aws iam add-user-to-group --user-name "metrics-exporter-${DEPLOY_ENV}" --group-name metrics-exporters

      - task: extract-cf-terraform-outputs
        config:
          platform: linux
          image_resource: *ruby-slim-image-resource
          inputs:
            - name: paas-cf
            - name: cf-tfstate
          outputs:
            - name: cf-terraform-outputs
          run:
            path: sh
            args:
              - -e
              - -c
              - |
                SCPATH="./paas-cf/concourse/scripts"
                SCFILE="extract_tf_vars_from_terraform_state.rb"
                $SCPATH/$SCFILE < cf-tfstate/cf.tfstate > cf-terraform-outputs/cf.tfstate.sh
                ls -l cf-terraform-outputs/cf.tfstate.sh

      - task: init-db
        config:
          platform: linux
          image_resource:
            type: docker-image
            source:
              repository: governmentpaas/psql
              tag: 465642da06051a55630d39c899697b678f66a7f7
          inputs:
            - name: terraform-variables
            - name: paas-cf
            - name: cf-terraform-outputs
          run:
            path: sh
            args:
              - -e
              - -c
              - |
                . terraform-variables/cf-secrets.tfvars.sh
                . cf-terraform-outputs/cf.tfstate.sh

                paas-cf/manifests/cf-manifest/scripts/create-cf-dbs.sh

  - name: generate-cf-config
    serial_groups: [cf-deploy]
    serial: true
    plan:
      - aggregate:
          - get: pipeline-trigger
            passed: ['cf-terraform']
            trigger: true
          - get: paas-cf
            passed: ['cf-terraform']
          - get: ipsec-CA
          - get: cf-secrets
            passed: ['cf-terraform']
          - get: cf-vars-store
          - get: vpc-tfstate
          - get: concourse-tfstate
          - get: bosh-tfstate
          - get: cf-tfstate
            passed: ['cf-terraform']
          - get: logit-secrets

      - aggregate:
        - task: extract-terraform-outputs
          config:
            platform: linux
            image_resource: *ruby-slim-image-resource
            inputs:
              - name: paas-cf
              - name: vpc-tfstate
              - name: bosh-tfstate
              - name: concourse-tfstate
              - name: cf-tfstate
            outputs:
              - name: terraform-outputs
            run:
              path: sh
              args:
                - -e
                - -c
                - |
                  for state in vpc bosh concourse cf; do
                    ./paas-cf/concourse/scripts/extract_terraform_state_to_yaml.rb \
                      < ${state}-tfstate/${state}.tfstate \
                      > terraform-outputs/${state}.yml
                    ./paas-cf/concourse/scripts/extract_tf_vars_from_terraform_state.rb \
                      < ${state}-tfstate/${state}.tfstate \
                      > terraform-outputs/${state}.tfvars.sh
                  done

        - task: generate-peer-opsfile
          config:
            platform: linux
            image_resource: *ruby-slim-image-resource
            inputs:
              - name: paas-cf
            outputs:
              - name: vpc-peering-opsfile
            run:
              path: sh
              args:
                - -e
                - -c
                - |
                  ruby paas-cf/terraform/scripts/generate_vpc_peering_opsfile.rb "paas-cf/terraform/((deploy_env)).vpc_peering.json" \
                  > vpc-peering-opsfile/vpc-peers.yml

                  cat vpc-peering-opsfile/vpc-peers.yml

        - task: generate-environment-variables
          config:
            platform: linux
            image_resource:
              type: docker-image
              source:
                repository: alpine
                tag: 3.7
            inputs:
              - name: paas-cf
            outputs:
              - name: environment-variables
            run:
              path: sh
              args:
                - -e
                - -c
                - |
                  cat <<EOF > environment-variables/environment-variables.yml
                  ---
                  system_domain: ((system_dns_zone_name))
                  app_domain: ((apps_dns_zone_name))
                  environment: ((deploy_env))
                  deployment_name: ((deploy_env))
                  aws_account: ((aws_account))
                  datadog_api_key: ((datadog_api_key))
                  datadog_app_key: ((datadog_app_key))
                  oauth_client_id: ((oauth_client_id))
                  oauth_client_secret: ((oauth_client_secret))
                  EOF

      - do:
        - task: generate-cloud-config
          config:
            platform: linux
            image_resource: *gov-paas-bosh-cli-v2-image-resource
            inputs:
              - name: paas-cf
              - name: terraform-outputs
              - name: cf-secrets
              - name: environment-variables
            outputs:
              - name: cloud-config
            params:
              CF_ENV_SPECIFIC_MANIFEST: paas-cf/manifests/cf-manifest/env-specific/((cf_env_specific_manifest))
            run:
              path: sh
              args:
                - -e
                - -c
                - |
                  paas-cf/manifests/cf-manifest/scripts/generate-cloud-config.sh > cloud-config/cloud-config.yml

          on_success:
            put: cloud-config
            params:
              file: cloud-config/cloud-config.yml

        - task: generate-cf-manifest
          config:
            platform: linux
            image_resource: *gov-paas-bosh-cli-v2-image-resource
            inputs:
              - name: cf-vars-store
              - name: paas-cf
              - name: ipsec-CA
              - name: terraform-outputs
              - name: cf-secrets
              - name: environment-variables
              - name: vpc-peering-opsfile
              - name: logit-secrets
            outputs:
              - name: cf-manifest
              - name: cf-manifest-pre-vars
              - name: cf-vars-store-updated
            params:
              CF_ENV_SPECIFIC_MANIFEST: paas-cf/manifests/cf-manifest/env-specific/((cf_env_specific_manifest))
              ENABLE_DATADOG: ((enable_datadog))
              DISABLE_USER_CREATION: ((disable_user_creation))
              SLIM_DEV_DEPLOYMENT: ((slim_dev_deployment))
            run:
              path: sh
              args:
                - -e
                - -u
                - -c
                - |
                  tar -xzf ./ipsec-CA/ipsec-CA.tar.gz -C ./ipsec-CA
                  cp cf-vars-store/cf-vars-store.yml cf-vars-store-updated/
                  ./paas-cf/manifests/cf-manifest/scripts/generate-manifest.sh \
                    --var-errs \
                    --vars-store cf-vars-store-updated/cf-vars-store.yml \
                    > cf-manifest/cf-manifest.yml
                  ./paas-cf/manifests/cf-manifest/scripts/generate-manifest.sh \
                    > cf-manifest-pre-vars/cf-manifest-pre-vars.yml

          on_success:
            aggregate:
            - put: cf-manifest
              params:
                file: cf-manifest/cf-manifest.yml
            - put: cf-manifest-pre-vars
              params:
                file: cf-manifest-pre-vars/cf-manifest-pre-vars.yml
            - put: cf-vars-store
              params:
                file: cf-vars-store-updated/cf-vars-store.yml

  - name: cf-deploy
    serial_groups: [cf-deploy]
    serial: true
    plan:
      - aggregate:
          - get: pipeline-trigger
            passed: ['generate-cf-config']
            trigger: true
          - get: paas-cf
            passed: ['generate-cf-config']
          - get: cloud-config
            passed: ['generate-cf-config']
          - get: cf-manifest
            passed: ['generate-cf-config']
          - get: bosh-secrets
          - get: bosh-CA-crt

      - aggregate:
        - task: get-and-upload-stemcell
          config:
            platform: linux
            image_resource: *gov-paas-bosh-cli-v2-image-resource
            inputs:
              - name: bosh-secrets
              - name: paas-cf
              - name: cf-manifest
              - name: bosh-CA-crt
            params:
              BOSH_ENVIRONMENT: ((bosh_fqdn))
              BOSH_CA_CERT: bosh-CA-crt/bosh-CA.crt
              BOSH_DEPLOYMENT: ((deploy_env))
            run:
              path: sh
              args:
                - -e
                - -c
                - |
                  VAL_FROM_YAML=$(pwd)/paas-cf/concourse/scripts/val_from_yaml.rb

                  stemcell_index=0
                  while true; do
                    if ! $VAL_FROM_YAML "stemcells.${stemcell_index}" cf-manifest/cf-manifest.yml > /dev/null 2>&1; then
                      break
                    fi

                    STEMCELL_VERSION=$($VAL_FROM_YAML "stemcells.${stemcell_index}.version" cf-manifest/cf-manifest.yml)
                    STEMCELL_OS=$($VAL_FROM_YAML "stemcells.${stemcell_index}.os" cf-manifest/cf-manifest.yml)

                    wget "https://bosh.io/d/stemcells/bosh-aws-xen-hvm-${STEMCELL_OS}-go_agent?v=${STEMCELL_VERSION}" -O stemcell.tgz
                    ./paas-cf/concourse/scripts/bosh_login.sh bosh-secrets/bosh-secrets.yml
                    bosh -n upload-stemcell stemcell.tgz

                    stemcell_index=$((stemcell_index + 1))
                  done

        - task: update-cloud-config
          config:
            platform: linux
            image_resource: *gov-paas-bosh-cli-v2-image-resource
            inputs:
              - name: cloud-config
              - name: bosh-secrets
              - name: paas-cf
              - name: bosh-CA-crt
            params:
              BOSH_ENVIRONMENT: ((bosh_fqdn))
              BOSH_CA_CERT: bosh-CA-crt/bosh-CA.crt
              BOSH_DEPLOYMENT: ((deploy_env))
            run:
              path: sh
              args:
                - -e
                - -c
                - |
                  ./paas-cf/concourse/scripts/bosh_login.sh bosh-secrets/bosh-secrets.yml
                  bosh -n update-cloud-config cloud-config/cloud-config.yml

      - task: cf-deploy
        config:
          platform: linux
          image_resource: *gov-paas-bosh-cli-v2-image-resource
          inputs:
            - name: paas-cf
            - name: cf-manifest
            - name: bosh-secrets
            - name: bosh-CA-crt
          params:
            BOSH_ENVIRONMENT: ((bosh_fqdn))
            BOSH_CA_CERT: bosh-CA-crt/bosh-CA.crt
            BOSH_DEPLOYMENT: ((deploy_env))
          run:
            path: sh
            args:
              - -e
              - -c
              - |
                ./paas-cf/concourse/scripts/bosh_login.sh bosh-secrets/bosh-secrets.yml
                bosh -n deploy cf-manifest/cf-manifest.yml

  - name: prometheus-deploy
    serial: true
    plan:
      - aggregate:
          - get: pipeline-trigger
            passed: ['cf-deploy']
            trigger: true
          - get: paas-cf
            passed: ['cf-deploy']
          - get: prometheus-vars-store
          - get: bosh-secrets
          - get: bosh-CA-crt

      - task: generate-prometheus-manifest
        config:
          platform: linux
          image_resource: *gov-paas-bosh-cli-v2-image-resource
          inputs:
            - name: paas-cf
            - name: prometheus-vars-store
            - name: bosh-secrets
            - name: bosh-CA-crt
          outputs:
            - name: prometheus-manifest
            - name: prometheus-vars-store-updated
          params:
            SYSTEM_DNS_ZONE_NAME: ((system_dns_zone_name))
            CF_DEPLOYMENT_NAME: ((deploy_env))
            BOSH_URL: https://((bosh_fqdn)):25555
            VARS_STORE: prometheus-vars-store-updated/prometheus-vars-store.yml
          run:
            path: sh
            args:
              - -e
              - -u
              - -c
              - |
                cp prometheus-vars-store/prometheus-vars-store.yml "${VARS_STORE}"

                export VARS_FILE=./prometheus-vars-file.yml

                bosh interpolate - \
                  --var-errs \
                  --vars-file bosh-secrets/bosh-secrets.yml \
                  --var-file bosh_ca_cert=./bosh-CA-crt/bosh-CA.crt \
                > ./prometheus-vars-file.yml \
                <<EOF
                ---
                metrics_environment: ${CF_DEPLOYMENT_NAME}
                bosh_url: ${BOSH_URL}
                bosh_username: prometheus
                bosh_password: ((secrets.bosh_prometheus_password))
                bosh_ca_cert: ((bosh_ca_cert))
                EOF


                ./paas-cf/manifests/prometheus/scripts/generate-manifest.sh \
                  > prometheus-manifest/prometheus-manifest.yml
        on_success:
          put: prometheus-vars-store
          params:
            file: prometheus-vars-store-updated/prometheus-vars-store.yml

      - task: prometheus-deploy
        config:
          platform: linux
          image_resource: *gov-paas-bosh-cli-v2-image-resource
          inputs:
            - name: paas-cf
            - name: prometheus-manifest
            - name: bosh-secrets
            - name: bosh-CA-crt
          params:
            BOSH_ENVIRONMENT: ((bosh_fqdn))
            BOSH_CA_CERT: bosh-CA-crt/bosh-CA.crt
            BOSH_DEPLOYMENT: prometheus
          run:
            path: sh
            args:
              - -e
              - -c
              - |
               ./paas-cf/concourse/scripts/bosh_login.sh bosh-secrets/bosh-secrets.yml
               bosh -n deploy prometheus-manifest/prometheus-manifest.yml

  - name: post-deploy
    serial: true
    plan:
    - aggregate:
      - get: pipeline-trigger
        passed: ['cf-deploy']
        trigger: true
      - get: paas-cf
        passed: ['cf-deploy']
      - get: cf-manifest
        passed: ['generate-cf-config']
      - get: cf-tfstate
        passed: ['generate-cf-config']
      - get: bosh-secrets
        passed: ['cf-deploy']
      - get: cf-vars-store
        passed: ['generate-cf-config']
      - get: bosh-CA-crt
      - get: datadog-tfstate
      - get: paas-aiven-broker
      - get: paas-billing
      - get: paas-accounts
      - get: paas-admin
      - get: paas-log-cache-adapter

    - task: retrieve-config
      config:
        platform: linux
        inputs:
          - name: paas-cf
          - name: cf-vars-store
          - name: cf-manifest
          - name: cf-tfstate
        outputs:
          - name: config
        params:
          SYSTEM_DNS_ZONE_NAME: ((system_dns_zone_name))
        image_resource: *ruby-slim-image-resource
        run:
          path: sh
          args:
            - -e
            - -c
            - |
              VAL_FROM_YAML=$(pwd)/paas-cf/concourse/scripts/val_from_yaml.rb

              ./paas-cf/concourse/scripts/extract_terraform_state_to_yaml.rb \
                < cf-tfstate/cf.tfstate \
                > cf-terraform-outputs.yml

              cat << EOT > config/config.sh
              export CF_ADMIN=admin
              export CF_PASS=$($VAL_FROM_YAML cf_admin_password cf-vars-store/cf-vars-store.yml)
              export API_ENDPOINT="https://api.${SYSTEM_DNS_ZONE_NAME}"
              export UAA_ENDPOINT=$($VAL_FROM_YAML instance_groups.api.jobs.cloud_controller_ng.properties.uaa.url cf-manifest/cf-manifest.yml)
              export DOPPLER_ENDPOINT=$($VAL_FROM_YAML instance_groups.scheduler.jobs.tps.properties.capi.tps.traffic_controller_url cf-manifest/cf-manifest.yml)
              export RDS_BROKER_SERVER=$($VAL_FROM_YAML terraform_outputs_rds_broker_elb_dns_name cf-terraform-outputs.yml)
              export RDS_BROKER_PASS=$($VAL_FROM_YAML secrets_rds_broker_admin_password cf-vars-store/cf-vars-store.yml)
              export CDN_BROKER_SERVER=$($VAL_FROM_YAML terraform_outputs_cdn_broker_elb_dns_name cf-terraform-outputs.yml)
              export CDN_BROKER_PASS=$($VAL_FROM_YAML secrets_cdn_broker_admin_password cf-vars-store/cf-vars-store.yml)
              export AIVEN_BROKER_PASS=$($VAL_FROM_YAML secrets_aiven_broker_admin_password cf-vars-store/cf-vars-store.yml)
              export BROKER_IP_WHITELIST=$($VAL_FROM_YAML terraform_outputs_nat_public_ips_csv cf-terraform-outputs.yml)
              export ELASTICACHE_BROKER_PASS=$($VAL_FROM_YAML secrets_elasticache_broker_admin_password cf-vars-store/cf-vars-store.yml)
              export ELASTICACHE_BROKER_SERVER=$($VAL_FROM_YAML terraform_outputs_elasticache_broker_elb_dns_name cf-terraform-outputs.yml)
              export METRICS_AWS_ACCESS_KEY_ID=$($VAL_FROM_YAML terraform_outputs_metrics_exporter_aws_access_key_id cf-terraform-outputs.yml)
              export METRICS_AWS_SECRET_ACCESS_KEY=$($VAL_FROM_YAML terraform_outputs_metrics_exporter_aws_secret_access_key cf-terraform-outputs.yml)
              EOT

              paas-cf/scripts/job_instances.rb cf-manifest/cf-manifest.yml \
                > config/job_instances.tfvars

              ls -l config/*

    - aggregate:
      - task: create-orgs
        config:
          platform: linux
          image_resource: *cf-cli-image-resource
          inputs:
            - name: paas-cf
            - name: config
          params:
            APPS_DNS_ZONE_NAME: ((apps_dns_zone_name))
          run:
            path: sh
            args:
              - -e
              - -c
              - |
                . ./config/config.sh
                echo | cf login -a "${API_ENDPOINT}" -u "${CF_ADMIN}" -p "${CF_PASS}"
                cf create-org admin
                cf set-quota admin medium

                cf create-space monitoring -o admin
                cf create-space service-brokers -o admin
                cf create-space healthchecks -o admin
                cf create-space billing -o admin
                cf create-space public -o admin
                cf create-space assets -o admin

                cf create-org govuk-paas
                cf set-quota govuk-paas medium
                cf create-space docs -o govuk-paas
                cf create-space tools -o govuk-paas
                cf target -o admin
                cf share-private-domain govuk-paas "((system_dns_zone_name))"

                # Reserve some domains so that tenants cannot create them to
                # mislead others
                cf target -o govuk-paas
                cf create-route docs "${APPS_DNS_ZONE_NAME}" --hostname www
                cf create-route docs "${APPS_DNS_ZONE_NAME}" --hostname api
                cf create-route docs "${APPS_DNS_ZONE_NAME}" --hostname status

                # Reserve the london app name so that we don't cause conflicts
                # when we roll out the London region.
                cf create-route docs "${APPS_DNS_ZONE_NAME}" --hostname london

      - task: register-rds-broker
        config:
          platform: linux
          image_resource: *cf-cli-image-resource
          inputs:
            - name: paas-cf
            - name: config
          run:
            path: sh
            args:
              - -e
              - -u
              - -c
              - |
                . ./config/config.sh
                echo | cf login -a "${API_ENDPOINT}" -u "${CF_ADMIN}" -p "${CF_PASS}"

                if cf service-brokers | grep 'rds-broker\s'; then
                  cf update-service-broker rds-broker rds-broker "${RDS_BROKER_PASS}" "https://${RDS_BROKER_SERVER}"
                else
                  cf create-service-broker rds-broker rds-broker "${RDS_BROKER_PASS}" "https://${RDS_BROKER_SERVER}"
                fi

                # Enable supported plans
                cat <<EOF | xargs -n1 cf enable-service-access mysql -p
                tiny-unencrypted-5.7
                small-5.7
                small-ha-5.7
                medium-ha-5.7
                medium-5.7
                large-ha-5.7
                large-5.7
                xlarge-ha-5.7
                xlarge-5.7
                EOF

                cat <<EOF | xargs -n1 cf enable-service-access postgres -p
                tiny-unencrypted-9.5
                small-ha-9.5
                small-9.5
                medium-ha-9.5
                medium-9.5
                large-ha-9.5
                large-9.5
                xlarge-ha-9.5
                xlarge-9.5
                EOF

                # Disable deprecated plans
                cat <<EOF | xargs -n1 cf disable-service-access mysql -p
                small-unencrypted-5.7
                small-ha-unencrypted-5.7
                medium-ha-unencrypted-5.7
                medium-unencrypted-5.7
                large-ha-unencrypted-5.7
                large-unencrypted-5.7
                xlarge-ha-unencrypted-5.7
                xlarge-unencrypted-5.7
                EOF

                cat <<EOF | xargs -n1 cf disable-service-access postgres -p
                small-ha-unencrypted-9.5
                small-unencrypted-9.5
                medium-ha-unencrypted-9.5
                medium-unencrypted-9.5
                large-ha-unencrypted-9.5
                large-unencrypted-9.5
                xlarge-ha-unencrypted-9.5
                xlarge-unencrypted-9.5
                EOF


      - task: register-cdn-broker
        config:
          platform: linux
          image_resource: *cf-cli-image-resource
          inputs:
            - name: paas-cf
            - name: config
          run:
            path: sh
            args:
              - -e
              - -u
              - -c
              - |
                . ./config/config.sh
                cf api "${API_ENDPOINT}"
                cf auth "${CF_ADMIN}" "${CF_PASS}"

                if cf service-brokers | grep 'cdn-broker\s'; then
                  cf update-service-broker cdn-broker cdn-broker "${CDN_BROKER_PASS}" "https://${CDN_BROKER_SERVER}"
                else
                  cf create-service-broker cdn-broker cdn-broker "${CDN_BROKER_PASS}" "https://${CDN_BROKER_SERVER}"
                fi
                cf enable-service-access cdn-route

      - task: set-security-groups-from-manifest
        config:
          platform: linux
          inputs:
            - name: paas-cf
            - name: config
            - name: cf-manifest
          params:
          image_resource: *cf-cli-image-resource
          run:
            path: sh
            args:
              - -e
              - -u
              - -c
              - |
                . ./config/config.sh
                echo | cf login -a "${API_ENDPOINT}" -u "${CF_ADMIN}" -p "${CF_PASS}"

                ./paas-cf/concourse/scripts/set_security_groups_from_manifest.rb cf-manifest/cf-manifest.yml

      - task: set-quotas-from-manifest
        config:
          platform: linux
          inputs:
            - name: paas-cf
            - name: config
            - name: cf-manifest
          params:
          image_resource: *cf-cli-image-resource
          run:
            path: sh
            args:
              - -e
              - -u
              - -c
              - |
                . ./config/config.sh

                echo | cf login -a "${API_ENDPOINT}" -u "${CF_ADMIN}" -p "${CF_PASS}"

                ./paas-cf/concourse/scripts/set_quotas_from_manifest.rb cf-manifest/cf-manifest.yml

      - task: enable-diego_docker-feature-flag
        config:
          platform: linux
          inputs:
            - name: paas-cf
            - name: config
          params:
          image_resource: *cf-cli-image-resource
          run:
            path: sh
            args:
              - -e
              - -u
              - -c
              - |
                . ./config/config.sh

                echo | cf login -a "${API_ENDPOINT}" -u "${CF_ADMIN}" -p "${CF_PASS}"

                cf enable-feature-flag diego_docker

      - task: ensure-internal-apps-domain-created
        config:
          platform: linux
          inputs:
            - name: paas-cf
            - name: config
          params:
          image_resource: *cf-cli-image-resource
          run:
            path: sh
            args:
              - -e
              - -u
              - -c
              - |
                . ./config/config.sh

                echo | cf login -a "${API_ENDPOINT}" -u "${CF_ADMIN}" -p "${CF_PASS}"

                if cf domains | awk '$1=="apps.internal" && $2=="shared" { r=1 } END { exit r }'; then
                  cf curl /v2/shared_domains -d '{"name": "apps.internal", "internal": true}'
                fi

    - aggregate:
      - task: block-create-account-endpoints
        config:
          platform: linux
          image_resource: *cf-cli-image-resource
          inputs:
            - name: paas-cf
            - name: config
          run:
            path: sh
            args:
              - -e
              - -u
              - -c
              - |
                . ./config/config.sh
                cf login -a "${API_ENDPOINT}" -u "${CF_ADMIN}" -p "${CF_PASS}" \
                  -o admin -s assets

                cd paas-cf/platform-tests/example-apps/create-account-holding-page/
                cf push

                if ! cf domains | grep -q "login.((system_dns_zone_name))"; then
                  cf create-domain admin "login.((system_dns_zone_name))"
                fi
                if ! cf domains | grep -q "uaa.((system_dns_zone_name))"; then
                  cf create-domain admin "uaa.((system_dns_zone_name))"
                fi

                cf target -s assets

                if ! cf routes | grep -qE "\\s+login.((system_dns_zone_name))\\s+/create_account(\\s+|$)"; then
                  cf create-route assets "login.((system_dns_zone_name))" --path create_account
                fi
                if ! cf routes | grep -qE "\\s+login.((system_dns_zone_name))\\s+/create_account\\.do(\\s+|$)"; then
                  cf create-route assets "login.((system_dns_zone_name))" --path create_account.do
                fi
                if ! cf routes | grep -qE "\\s+uaa.((system_dns_zone_name))\\s+/create_account(\\s+|$)"; then
                  cf create-route assets "uaa.((system_dns_zone_name))" --path create_account
                fi
                if ! cf routes | grep -qE "\\s+uaa.((system_dns_zone_name))\\s+/create_account\\.do(\\s+|$)"; then
                  cf create-route assets "uaa.((system_dns_zone_name))" --path create_account.do;
                fi

                cf map-route create-account-holding-page "login.((system_dns_zone_name))" --path create_account
                cf map-route create-account-holding-page "login.((system_dns_zone_name))" --path create_account.do
                cf map-route create-account-holding-page "uaa.((system_dns_zone_name))" --path create_account
                cf map-route create-account-holding-page "uaa.((system_dns_zone_name))" --path create_account.do

      - task: deploy-simulated-load-application
        config:
          platform: linux
          image_resource: *cf-cli-image-resource
          params:
            TEST_HEAVY_LOAD: ((test_heavy_load))
          inputs:
            - name: paas-cf
            - name: config
          run:
            path: sh
            args:
              - -e
              - -u
              - -c
              - |
                if [ "${TEST_HEAVY_LOAD:-}" != "true" ] ; then
                  echo Heavy load test has been disabled. Skipping...
                  exit 0
                fi

                . ./config/config.sh
                echo | cf login -a "${API_ENDPOINT}" -u "${CF_ADMIN}" -p "${CF_PASS}"

                cf target -o admin -s healthchecks

                cd paas-cf/platform-tests/example-apps/healthcheck
                cf push simulated-load -i 180

                timeout=300
                deadline=$(($(date +%s) + timeout))

                checkInstances() {
                  instances=$(cf app simulated-load | awk '/instances: / { print $2 }')
                  RUNNING=$(echo "${instances}" | awk -F / '{ print $1 }')
                  EXPECTED=$(echo "${instances}" | awk -F / '{ print $2 }')

                  if [ "${RUNNING}" -lt "${EXPECTED}" ]; then
                    return "1";
                  fi

                  return "0";
                }

                while [ "$(checkInstances && echo $?)" -eq "1" ]; do
                  sleep 5
                  echo "Retrying $((timeout - (deadline - $(date +%s))))s..."

                  if [ "$(date +%s)" -gt "${deadline}" ] ; then
                    echo "We're expecting ${EXPECTED} number of instance(s) to run."
                    echo "Only ${RUNNING} instance(s) running..."

                    exit 1
                  fi
                done

                echo Done!

      - task: sync-admin-users
        config:
          platform: linux
          image_resource:
            type: docker-image
            source:
              repository: ruby
              tag: "2.5"
          inputs:
            - name: paas-cf
            - name: config
            - name: cf-vars-store
            - name: cf-manifest
          params:
            DISABLE_USER_CREATION: ((disable_user_creation))
          run:
            path: sh
            args:
              - -e
              - -c
              - |
                ${DISABLE_USER_CREATION} && echo "WARNING: Admin user creation disabled in this environment!" && exit 0

                . ./config/config.sh

                VAL_FROM_YAML=$(pwd)/paas-cf/concourse/scripts/val_from_yaml.rb
                export CF_ADMIN_PASSWORD
                CF_ADMIN_PASSWORD=$($VAL_FROM_YAML cf_admin_password cf-vars-store/cf-vars-store.yml)
                cd paas-cf/scripts
                bundle
                bundle exec sync-admin-users.rb "${API_ENDPOINT}" ../config/admin_users.yml "((NEW_ACCOUNT_EMAIL_ADDRESS))"

      - task: deploy-healthcheck
        config:
          platform: linux
          image_resource: *cf-cli-image-resource
          params:
            DISABLE_HEALTHCHECK_DB: ((disable_healthcheck_db))
            APPS_DNS_ZONE_NAME: ((apps_dns_zone_name))
          inputs:
            - name: paas-cf
            - name: config
          outputs:
            - name: deployed-healthcheck
          run:
            path: sh
            args:
              - -e
              - -u
              - -c
              - |
                . ./config/config.sh
                echo | cf login -a "${API_ENDPOINT}" -u "${CF_ADMIN}" -p "${CF_PASS}"

                cf target -o admin -s healthchecks
                BUILD_ROOT=$(pwd)
                cd paas-cf/platform-tests/example-apps/healthcheck

                if  [ "${DISABLE_HEALTHCHECK_DB:-}" != "true" ] ; then

                  if ! cf service healthcheck-db > /dev/null; then
                    cf create-service postgres tiny-unencrypted-9.5 healthcheck-db
                    while ! cf service healthcheck-db | grep -q 'create succeeded'; do
                      echo "Waiting for creation of service to complete..."
                      sleep 30
                    done
                  fi

                  ruby -ryaml -e '
                    manifest = YAML.load_file("manifest.yml")
                    manifest["applications"].each { |app| app["services"] = ["healthcheck-db"] }
                    File.write("manifest.yml", manifest.to_yaml)
                  '
                fi

                ruby -ryaml -e "
                  manifest = YAML.load_file('manifest.yml')
                  manifest['applications'].each do |app|
                    app['routes'] = [
                      { 'route' => 'healthcheck.${APPS_DNS_ZONE_NAME}' }
                    ]
                  end
                  File.write('manifest.yml', manifest.to_yaml)
                "

                cf zero-downtime-push healthcheck -f manifest.yml

                cd "${BUILD_ROOT}"
                echo "yes" > deployed-healthcheck/healthcheck-deployed
        on_success:
          put: deployed-healthcheck
          params:
            file: deployed-healthcheck/healthcheck-deployed

      - task: deploy-paas-billing
        config:
          platform: linux
          image_resource: *cf-cli-image-resource
          params:
            SYSTEM_DNS_ZONE_NAME: ((system_dns_zone_name))
            DEPLOY_ENV: ((deploy_env))
          inputs:
            - name: paas-cf
            - name: paas-billing
            - name: config
            - name: cf-vars-store
          run:
            path: sh
            args:
              - -e
              - -u
              - -c
              - |
                BILLING_DB_PLAN="tiny-unencrypted-9.5"
                if [ "${DEPLOY_ENV}" = "prod" ]; then
                  BILLING_DB_PLAN="medium-9.5"
                fi

                VAL_FROM_YAML=$(pwd)/paas-cf/concourse/scripts/val_from_yaml.rb
                CF_CLIENT_SECRET=$($VAL_FROM_YAML secrets_uaa_clients_paas_billing_secret cf-vars-store/cf-vars-store.yml)

                . ./config/config.sh
                echo | cf login -a "${API_ENDPOINT}" -u "${CF_ADMIN}" -p "${CF_PASS}" -o admin -s billing

                if ! cf service billing-db > /dev/null; then
                  cf create-service postgres "${BILLING_DB_PLAN}" billing-db
                  while ! cf service billing-db | grep -iqE 'status:\s+create succeeded'; do
                    echo "Waiting for creation of service to complete..."
                    sleep 30
                  done
                fi

                cp paas-cf/config/billing/config.json paas-billing/

                cd paas-billing

                ruby -ryaml -e "
                  env = {
                    'CF_CLIENT_ID' => 'paas-billing',
                    'CF_CLIENT_SECRET' => '${CF_CLIENT_SECRET}',
                    'CF_CLIENT_REDIRECT_URL' => 'https://billing.${SYSTEM_DNS_ZONE_NAME}/oauth/callback',
                    'CF_API_ADDRESS' => '${API_ENDPOINT}',
                  }
                  manifest = YAML.load_file('manifest.yml')
                  manifest['applications'].each { |app|
                    app['env'] = {} unless app['env']
                    app['env'].merge!(env)
                    app['services'] = ['billing-db']
                    app['routes'] = [
                      { 'route' => 'billing.${SYSTEM_DNS_ZONE_NAME}' }
                    ]
                  }
                  File.write('manifest.yml', manifest.to_yaml)
                "

                cf push paas-billing

      - task: deploy-paas-accounts
        config:
          platform: linux
          image_resource: *cf-cli-image-resource
          params:
            SYSTEM_DNS_ZONE_NAME: ((system_dns_zone_name))
            DEPLOY_ENV: ((deploy_env))
          inputs:
            - name: paas-cf
            - name: paas-accounts
            - name: config
            - name: cf-vars-store
          run:
            path: sh
            args:
              - -e
              - -u
              - -c
              - |
                DB_PLAN="tiny-unencrypted-9.5"

                VAL_FROM_YAML=$(pwd)/paas-cf/concourse/scripts/val_from_yaml.rb
                BASIC_AUTH_PASSWORD=$($VAL_FROM_YAML secrets_paas_accounts_admin_password cf-vars-store/cf-vars-store.yml)

                . ./config/config.sh
                echo | cf login -a "${API_ENDPOINT}" -u "${CF_ADMIN}" -p "${CF_PASS}" -o admin -s billing

                if ! cf service accounts-db > /dev/null; then
                  cf create-service postgres "${DB_PLAN}" accounts-db
                  while ! cf service accounts-db | grep -iqE 'status:\s+create succeeded'; do
                    echo "Waiting for creation of service to complete..."
                    sleep 30
                  done
                fi

                cd paas-accounts

                ruby -ryaml -e "
                  env = {
                    'BASIC_AUTH_USERNAME' => 'admin',
                    'BASIC_AUTH_PASSWORD' => '${BASIC_AUTH_PASSWORD}',
                  }
                  manifest = YAML.load_file('manifest.yml')
                  manifest['applications'].each { |app|
                    app['env'] = {} unless app['env']
                    app['env'].merge!(env)
                    app['services'] = ['accounts-db']
                    app['routes'] = [
                      { 'route' => 'accounts.${SYSTEM_DNS_ZONE_NAME}' }
                    ]
                  }
                  File.write('manifest.yml', manifest.to_yaml)
                "
                cf push paas-accounts

      - do:
        - task: build-paas-admin
          config:
            platform: linux
            image_resource:
              type: docker-image
              source:
                repository: node
                tag: 8-alpine
            inputs:
              - name: paas-admin
            outputs:
              - name: paas-admin-dist
            run:
              path: sh
              args:
                - -e
                - -u
                - -c
                - |
                  cd paas-admin
                  npm install
                  NODE_ENV=production npm run build

                  cp -Ra . ../paas-admin-dist

        - task: render-manifest-paas-admin
          config:
            platform: linux
            image_resource:
              type: docker-image
              source:
                repository: governmentpaas/spruce
                tag: c735581beb174ecc95ca1a7b57eff444af3bf099
            inputs:
              - name: paas-cf
              - name: paas-admin-dist
              - name: cf-vars-store
            outputs:
              - name: paas-admin-manifest
            params:
              SYSTEM_DNS_ZONE_NAME: ((system_dns_zone_name))
              NOTIFY_API_KEY: ((notify_api_key))
              NOTIFY_WELCOME_TEMPLATE_ID: 1859ce68-f133-4218-ac6e-a8ef32a41292
            run:
              path: sh
              args:
                - -e
                - -c
                - |
                  cat <<EOF > paas-admin-env-and-routes.yml
                  applications:
                  - name: paas-admin
                    routes:
                    - route: "admin.${SYSTEM_DNS_ZONE_NAME}"
                    instances: 2
                    env:
                      OAUTH_CLIENT_ID: "paas-admin"
                      OAUTH_CLIENT_SECRET: "(( grab uaa_clients_paas_admin_secret ))"
                      API_URL: "https://api.${SYSTEM_DNS_ZONE_NAME}"
                      BILLING_URL: "https://billing.${SYSTEM_DNS_ZONE_NAME}"
                      ACCOUNTS_URL: "https://accounts.${SYSTEM_DNS_ZONE_NAME}"
                      ACCOUNTS_SECRET: "(( grab secrets_paas_accounts_admin_password ))"
                      NOTIFY_API_KEY: "${NOTIFY_API_KEY}"
                      NOTIFY_WELCOME_TEMPLATE_ID: "${NOTIFY_WELCOME_TEMPLATE_ID}"
                      SESSION_SECRET: (( concat "session-" uaa_clients_paas_admin_secret ))
                  EOF

                  spruce merge \
                    paas-admin-dist/manifest.yml \
                    paas-admin-env-and-routes.yml \
                    cf-vars-store/cf-vars-store.yml \
                    | spruce merge --cherry-pick applications \
                      > paas-admin-manifest/manifest.yml

        - task: deploy-paas-admin
          config:
            platform: linux
            image_resource: *cf-cli-image-resource
            inputs:
              - name: paas-cf
              - name: paas-admin-dist
              - name: paas-admin-manifest
              - name: config
              - name: cf-vars-store
            params:
              SYSTEM_DNS_ZONE_NAME: ((system_dns_zone_name))
            run:
              path: sh
              args:
                - -e
                - -u
                - -c
                - |
                  VAL_FROM_YAML=$(pwd)/paas-cf/concourse/scripts/val_from_yaml.rb
                  export CF_CLIENT_SECRET
                  CF_CLIENT_SECRET=$($VAL_FROM_YAML secrets_uaa_clients_paas_billing_secret cf-vars-store/cf-vars-store.yml)

                  . ./config/config.sh
                  cf api "${API_ENDPOINT}"
                  cf auth "${CF_ADMIN}" "${CF_PASS}"
                  cf target -o admin -s public

                  cd paas-admin-dist

                  cf zero-downtime-push paas-admin -f ../paas-admin-manifest/manifest.yml

      - do:
        - task: deploy-paas-log-cache-adapter
          config:
            platform: linux
            image_resource: *cf-cli-image-resource
            inputs:
              - name: paas-cf
              - name: paas-log-cache-adapter
              - name: config
            params:
              SYSTEM_DNS_ZONE_NAME: ((system_dns_zone_name))
            run:
              path: sh
              args:
                - -e
                - -u
                - -c
                - |
                  . ./config/config.sh
                  cf api "${API_ENDPOINT}"
                  cf auth "${CF_ADMIN}" "${CF_PASS}"
                  cf target -o admin -s monitoring

                  cd paas-log-cache-adapter

                  ruby -ryaml -e "
                    env = {
                      'LOG_CACHE_API' => 'https://log-cache.${SYSTEM_DNS_ZONE_NAME}',
                    }
                    manifest = YAML.load_file('manifest.yml')
                    manifest['applications'].each { |app|
                      app['env'] = {} unless app['env']
                      app['env'].merge!(env)
                      app['routes'] = [
                        { 'route' => 'metrics.${SYSTEM_DNS_ZONE_NAME}' }
                      ]
                    }
                    File.write('manifest.yml', manifest.to_yaml)
                  "

                  cf zero-downtime-push paas-log-cache-adapter -f manifest.yml

      - task: run-bosh-cleanup
        config:
          platform: linux
          image_resource: *gov-paas-bosh-cli-v2-image-resource
          inputs:
            - name: paas-cf
            - name: bosh-secrets
            - name: bosh-CA-crt
          params:
            BOSH_ENVIRONMENT: ((bosh_fqdn))
            BOSH_CA_CERT: bosh-CA-crt/bosh-CA.crt
            BOSH_DEPLOYMENT: ((deploy_env))
          run:
            path: sh
            args:
              - -e
              - -c
              - |
                ./paas-cf/concourse/scripts/bosh_login.sh bosh-secrets/bosh-secrets.yml
                bosh -n clean-up --all

    - aggregate:
      - do:
        - task: deploy-aiven-service-broker
          config:
            platform: linux
            image_resource: *cf-cli-image-resource
            inputs:
              - name: paas-cf
              - name: paas-aiven-broker
              - name: config
            params:
              AIVEN_API_TOKEN: ((aiven_api_token))
              SERVICE_NAME_PREFIX: ((deploy_env))
              AIVEN_PROJECT: paas-cf-((aws_account))
              AIVEN_CLOUD: aws-((aws_region))
              APPS_DNS_ZONE_NAME: ((apps_dns_zone_name))
            run:
              path: sh
              args:
                - -e
                - -u
                - -c
                - |
                  . ./config/config.sh
                  cf login -a "${API_ENDPOINT}" -u "${CF_ADMIN}" -p "${CF_PASS}" \
                    -o admin -s service-brokers

                  cp ./paas-cf/config/service-brokers/aiven/config.json ./paas-aiven-broker/
                  cd paas-aiven-broker/

                  ruby -ryaml -e "
                    env = {
                      'AIVEN_USERNAME' => 'aiven-broker',
                      'AIVEN_PASSWORD' => '$AIVEN_BROKER_PASS',
                      'AIVEN_API_TOKEN' => '$AIVEN_API_TOKEN',
                      'SERVICE_NAME_PREFIX' => '$SERVICE_NAME_PREFIX',
                      'AIVEN_PROJECT' => '$AIVEN_PROJECT',
                      'AIVEN_CLOUD' => '$AIVEN_CLOUD',
                      'IP_WHITELIST' => '$BROKER_IP_WHITELIST',
                    }
                    manifest = YAML.load_file('manifest.yml')
                    manifest['applications'].each { |app|
                      app['env'] ||= {}
                      app['env'].merge!(env)
                    }
                    File.write('manifest.yml', manifest.to_yaml)
                  "
                  cf blue-green-deploy aiven-broker
                  cf delete -f aiven-broker-old

                  if cf service-brokers | grep 'aiven-broker\s'; then
                    cf update-service-broker aiven-broker aiven-broker "$AIVEN_BROKER_PASS" "https://aiven-broker.${APPS_DNS_ZONE_NAME}"
                  else
                    cf create-service-broker aiven-broker aiven-broker "$AIVEN_BROKER_PASS" "https://aiven-broker.${APPS_DNS_ZONE_NAME}"
                  fi
                  cf enable-service-access elasticsearch

        - task: register-elasticache-broker
          config:
            platform: linux
            image_resource: *cf-cli-image-resource
            inputs:
              - name: paas-cf
              - name: config
            run:
              path: sh
              args:
                - -e
                - -u
                - -c
                - |
                  . ./config/config.sh
                  echo | cf login -a "${API_ENDPOINT}" -u "${CF_ADMIN}" -p "${CF_PASS}"

                  if cf service-brokers | grep 'elasticache-broker\s'; then
                    cf update-service-broker elasticache-broker elasticache-broker "${ELASTICACHE_BROKER_PASS}" "https://${ELASTICACHE_BROKER_SERVER}"
                  else
                    cf create-service-broker elasticache-broker elasticache-broker "${ELASTICACHE_BROKER_PASS}" "https://${ELASTICACHE_BROKER_SERVER}"
                  fi
                  cf enable-service-access redis

      - task: datadog-terraform-apply
        config:
          platform: linux
          image_resource: *terraform-image-resource
          inputs:
            - name: datadog-tfstate
            - name: paas-cf
            - name: config
          outputs:
            - name: updated-tfstate
          params:
            TF_VAR_env: ((deploy_env))
            TF_VAR_datadog_api_key: ((datadog_api_key))
            TF_VAR_datadog_app_key: ((datadog_app_key))
            TF_VAR_aws_account: ((aws_account))
            TF_VAR_region: ((aws_region))
            ENABLE_DATADOG: ((enable_datadog))
          run:
            path: sh
            args:
              - -e
              - -c
              - |
                cp datadog-tfstate/datadog.tfstate updated-tfstate/datadog.tfstate
                terraform init paas-cf/terraform/datadog

                if [ -n "${TF_VAR_datadog_api_key}" ] && [ -n "${TF_VAR_datadog_app_key}" ] && [ "${ENABLE_DATADOG}" = "false" ]; then
                  echo "Datadog disabled but keys present, running check cleanup..."
                  terraform destroy -force \
                      -state=updated-tfstate/datadog.tfstate \
                      -var-file="paas-cf/terraform/${TF_VAR_aws_account}.tfvars" \
                      paas-cf/terraform/datadog
                  exit 0
                fi

                if [ "${ENABLE_DATADOG}" = "true" ]; then
                  terraform apply \
                    -auto-approve=true \
                    -var-file="paas-cf/terraform/((aws_account)).tfvars" \
                    -state=updated-tfstate/datadog.tfstate \
                    -var-file=config/job_instances.tfvars \
                    paas-cf/terraform/datadog
                else
                  echo "Datadog disabled, skipping terraform run..."
                  cp datadog-tfstate/datadog.tfstate updated-tfstate/datadog.tfstate
                fi
        ensure:
          put: datadog-tfstate
          params:
            file: updated-tfstate/datadog.tfstate

      - task: deploy-paas-metrics
        config:
          platform: linux
          image_resource: *cf-cli-image-resource
          params:
            ENABLE_DATADOG: ((enable_datadog))
            DATADOG_API_KEY: ((datadog_api_key))
            DATADOG_APP_KEY: ((datadog_app_key))
            DEPLOY_ENV: ((deploy_env))
            APPS_DNS_ZONE_NAME: ((apps_dns_zone_name))
            SYSTEM_DNS_ZONE_NAME: ((system_dns_zone_name))
            AWS_REGION: ((aws_region))
            AIVEN_API_TOKEN: ((aiven_api_token))
            AIVEN_PROJECT: paas-cf-((aws_account))
          inputs:
            - name: paas-cf
            - name: config
            - name: cf-vars-store
          run:
            path: sh
            args:
              - -e
              - -u
              - -c
              - |
                if  [ "${ENABLE_DATADOG:-}" != "true" ] ; then
                  echo "ENABLE_DATADOG=${ENABLE_DATADOG} so skipping paas-metrics deploy"
                  exit 0
                fi

                VAL_FROM_YAML=$(pwd)/paas-cf/concourse/scripts/val_from_yaml.rb
                METRICS_SECRET=$($VAL_FROM_YAML secrets_uaa_clients_paas_metrics_secret cf-vars-store/cf-vars-store.yml)

                . ./config/config.sh
                echo | cf login -a "${API_ENDPOINT}" -u "${CF_ADMIN}" -p "${CF_PASS}" -o admin -s monitoring

                cd paas-cf/tools/metrics

                ruby -ryaml -e "
                  env = {
                    'CF_CLIENT_ID' => 'paas-metrics',
                    'CF_CLIENT_SECRET' => '${METRICS_SECRET}',
                    'CF_API_ADDRESS' => '${API_ENDPOINT}',
                    'CF_SKIP_SSL_VALIDATION' => 'true',
                    'DATADOG_API_KEY' => '${DATADOG_API_KEY:-}',
                    'DATADOG_APP_KEY' => '${DATADOG_APP_KEY:-}',
                    'DEPLOY_ENV' => '${DEPLOY_ENV}',
                    'ELB_ADDRESS' => 'https://healthcheck.${APPS_DNS_ZONE_NAME}/',
                    'TLS_DOMAINS' => [
                      'healthcheck.${APPS_DNS_ZONE_NAME}',
                      'api.${SYSTEM_DNS_ZONE_NAME}',
                      'uaa.${SYSTEM_DNS_ZONE_NAME}',
                      '${APPS_DNS_ZONE_NAME}'
                    ].join(','),
                    'AWS_REGION' => '${AWS_REGION}',
                    'AWS_ACCESS_KEY_ID' => '${METRICS_AWS_ACCESS_KEY_ID}',
                    'AWS_SECRET_ACCESS_KEY' => '${METRICS_AWS_SECRET_ACCESS_KEY}',
                    'AIVEN_API_TOKEN' => '${AIVEN_API_TOKEN}',
                    'AIVEN_PROJECT' => '${AIVEN_PROJECT}'
                  }
                  manifest = YAML.load_file('manifest.yml')
                  manifest['applications'].each { |app|
                    app['env'] = {} unless app['env']
                    app['env'].merge!(env)
                  }
                  File.write('manifest.yml', manifest.to_yaml)
                "

                cf push paas-metrics

      - task: deploy-paas-uaa-assets
        config:
          platform: linux
          image_resource: *cf-cli-image-resource
          inputs:
            - name: paas-cf
            - name: config
          run:
            path: sh
            args:
              - -e
              - -u
              - -c
              - |
                . ./config/config.sh
                echo | cf login -a "${API_ENDPOINT}" -u "${CF_ADMIN}" -p "${CF_PASS}" -o admin -s assets

                cd paas-cf/tools/paas-uaa-assets

                cf blue-green-deploy paas-uaa-assets
                cf delete -f paas-uaa-assets-old

      - task: remove-unused-ses-smtp-access-keys
        config:
          platform: linux
          image_resource: *awscli-image-resource
          inputs:
            - name: cf-tfstate
          params:
            DEPLOY_ENV: ((deploy_env))
            AWS_DEFAULT_REGION: ((aws_region))
          run:
            path: sh
            args:
              - -e
              - -c
              - |
                delete_unused_keys() {
                  terraform_outputs_key=$1
                  username=$2

                  jq_path=".modules[].outputs.${terraform_outputs_key}.value"
                  ACCESS_KEY_ID=$(jq -r "$jq_path" cf-tfstate/cf.tfstate)
                  if [ -z "$ACCESS_KEY_ID" ]; then
                    echo "could not find $terraform_outputs_key in terraform outputs"
                    exit 1
                  fi

                  UNUSED_ACCESS_KEYS=$(\
                    aws iam list-access-keys --user-name "$username" \
                    --query "AccessKeyMetadata[?AccessKeyId!=\`${ACCESS_KEY_ID}\`].AccessKeyId" \
                    --output text \
                  )
                  if [ -z "$UNUSED_ACCESS_KEYS" ]; then
                    echo "no access keys to revoke"
                  else
                    for key in $UNUSED_ACCESS_KEYS; do
                      echo "deleting key $key for user $username"
                      aws iam delete-access-key --user-name "$username" --access-key-id "$key"
                    done
                  fi
                }

                delete_unused_keys ses_smtp_aws_access_key_id "ses-smtp-${DEPLOY_ENV}"
                delete_unused_keys metrics_exporter_aws_access_key_id "metrics-exporter-${DEPLOY_ENV}"

  - name: smoke-tests
    serial_groups: [smoke-tests]
    plan:
      - aggregate:
          - get: pipeline-trigger
            passed: ['post-deploy','app-availability-tests','api-availability-tests']
            trigger: true
          - get: cf-smoke-tests-release
          - get: paas-cf
            passed: ['post-deploy','app-availability-tests','api-availability-tests']
          - get: cf-manifest
            passed: ['post-deploy']
          - get: cf-vars-store
            passed: ['post-deploy']

      - do:
        - task: create-temp-user
          file: paas-cf/concourse/tasks/create_admin.yml
          params:
            PREFIX: smoketest-user

        - task: smoke-tests-config
          file: paas-cf/concourse/tasks/generate-test-config.yml
          params:
            TEST_PROPERTIES: smoke_tests
            APP_DOMAIN: ((apps_dns_zone_name))
            SYSTEM_DOMAIN: ((system_dns_zone_name))

        - task: smoke-tests-run
          file: paas-cf/concourse/tasks/smoke-tests-run.yml
          ensure:
            task: upload-test-artifacts
            file: paas-cf/concourse/tasks/upload-test-artifacts.yml
            params:
              TEST_ARTIFACTS_BUCKET: ((test_artifacts_bucket))

        ensure:
          task: remove-temp-user
          file: paas-cf/concourse/tasks/delete_admin.yml

  - name: acceptance-tests
    plan:
      - aggregate:
          - get: pipeline-trigger
            passed: ['post-deploy','app-availability-tests','api-availability-tests']
            trigger: true
          - get: cf-acceptance-tests
          - get: paas-cf
            passed: ['post-deploy','app-availability-tests','api-availability-tests']
          - get: cf-manifest
            passed: ['post-deploy']
          - get: cf-vars-store
            passed: ['post-deploy']

      - do:
        - task: create-temp-user
          file: paas-cf/concourse/tasks/create_admin.yml
          params:
            PREFIX: acceptance-test-user
            DISABLE_ADMIN_USER_CREATION: ((disable_cf_acceptance_tests))

        - do:
          - task: generate-test-config
            file: paas-cf/concourse/tasks/generate-test-config.yml
            params:
              TEST_PROPERTIES: acceptance_tests
              APP_DOMAIN: ((apps_dns_zone_name))
              SYSTEM_DOMAIN: ((system_dns_zone_name))
          - task: run-tests
            config:
              platform: linux
              image_resource: *cf-acceptance-tests-image-resource
              params:
                DISABLE_CF_ACCEPTANCE_TESTS: ((disable_cf_acceptance_tests))
              inputs:
                - name: paas-cf
                - name: cf-acceptance-tests
                  path: src/github.com/cloudfoundry/cf-acceptance-tests
                - name: test-config
              outputs:
                - name: artifacts
                  path: /tmp/artifacts
              run:
                path: ./paas-cf/platform-tests/upstream/run_acceptance_tests.sh
            ensure:
              task: upload-test-artifacts
              file: paas-cf/concourse/tasks/upload-test-artifacts.yml
              params:
                TEST_ARTIFACTS_BUCKET: ((test_artifacts_bucket))
          ensure:
            task: remove-temp-user
            file: paas-cf/concourse/tasks/delete_admin.yml
            params:
              DISABLE_ADMIN_USER_CREATION: ((disable_cf_acceptance_tests))

  - name: log-cache-acceptance-tests
    plan:
      - aggregate:
          - get: pipeline-trigger
            passed: ['post-deploy','app-availability-tests','api-availability-tests']
            trigger: true
          - get: cf-acceptance-tests
          - get: paas-cf
            passed: ['post-deploy','app-availability-tests','api-availability-tests']
          - get: cf-manifest
            passed: ['post-deploy']
          - get: cf-vars-store
            passed: ['post-deploy']

      - do:
        - task: create-temp-user
          file: paas-cf/concourse/tasks/create_admin.yml
          params:
            PREFIX: acceptance-test-user
            DISABLE_ADMIN_USER_CREATION: ((disable_cf_acceptance_tests))

        - do:
          - task: generate-test-config
            file: paas-cf/concourse/tasks/generate-test-config.yml
            params:
              TEST_PROPERTIES: acceptance_log_cache_tests
              APP_DOMAIN: ((apps_dns_zone_name))
              SYSTEM_DOMAIN: ((system_dns_zone_name))
          - task: run-log-cache-tests
            timeout: 20m
            config:
              platform: linux
              image_resource: *cf-acceptance-tests-image-resource
              params:
                DISABLE_CF_ACCEPTANCE_TESTS: ((disable_cf_acceptance_tests))
                SKIP_REGEX: "exercises basic loggregator behavior|applies default environment variables while running apps and tasks|applies default environment variables while staging apps"
              inputs:
                - name: paas-cf
                - name: cf-acceptance-tests
                  path: src/github.com/cloudfoundry/cf-acceptance-tests
                - name: test-config
              run:
                path: ./paas-cf/platform-tests/upstream/run_acceptance_tests.sh
          ensure:
            task: remove-temp-user
            file: paas-cf/concourse/tasks/delete_admin.yml
            params:
              DISABLE_ADMIN_USER_CREATION: ((disable_cf_acceptance_tests))

  - name: custom-acceptance-tests
    plan:
      - aggregate:
          - get: pipeline-trigger
            passed: ['post-deploy','app-availability-tests','api-availability-tests']
            trigger: true
          - get: paas-cf
            passed: ['post-deploy','app-availability-tests','api-availability-tests']
          - get: cf-manifest
            passed: ['post-deploy']
          - get: cf-vars-store
            passed: ['post-deploy']
          - get: cf-acceptance-tests
          - get: paas-admin
            passed: ['post-deploy']

      - do:
        - task: create-temp-user
          file: paas-cf/concourse/tasks/create_admin.yml
          params:
            PREFIX: custom-acceptance-test-user
            DISABLE_ADMIN_USER_CREATION: ((disable_custom_acceptance_tests))

        - task: generate-test-config
          file: paas-cf/concourse/tasks/generate-test-config.yml
          params:
            TEST_PROPERTIES: acceptance_tests
            APP_DOMAIN: ((apps_dns_zone_name))
            SYSTEM_DOMAIN: ((system_dns_zone_name))
            NAME_PREFIX: ACC

        - aggregate:
          - task: "Run custom acceptance tests"
            file: paas-cf/concourse/tasks/custom-acceptance-tests-run.yml
            params:
              DISABLE_CUSTOM_ACCEPTANCE_TESTS: ((disable_custom_acceptance_tests))
              DEPLOY_ENV: ((deploy_env))
              AWS_REGION: ((aws_region))
              SYSTEM_DNS_ZONE_NAME: ((system_dns_zone_name))
              SLIM_DEV_DEPLOYMENT: ((slim_dev_deployment))
            ensure:
              task: upload-test-artifacts
              file: paas-cf/concourse/tasks/upload-test-artifacts.yml
              params:
                TEST_ARTIFACTS_BUCKET: ((test_artifacts_bucket))

          - task: "Run paas-admin integration tests"
            config:
              platform: linux
              image_resource:
                type: docker-image
                source:
                  repository: node
                  tag: 8-alpine
              params:
                DISABLE_CUSTOM_ACCEPTANCE_TESTS: ((disable_custom_acceptance_tests))
                DEPLOY_ENV: ((deploy_env))
                SYSTEM_DNS_ZONE_NAME: ((system_dns_zone_name))
              inputs:
                - name: paas-cf
                - name: paas-admin
                - name: admin-creds
                - name: cf-vars-store
              run:
                path: sh
                args:
                  - -e
                  - -u
                  - -c
                  - |
                    if [ "${DISABLE_CUSTOM_ACCEPTANCE_TESTS:-}" = "true" ]; then
                      echo 'Skipping because DISABLE_CUSTOM_ACCEPTANCE_TESTS is set'
                      exit 0
                    fi
                    cd paas-admin
                    npm install

                    ADMIN_USERNAME="$(cat ../admin-creds/username)" \
                    ADMIN_PASSWORD="$(cat ../admin-creds/password)" \
                    PAAS_ADMIN_BASE_URL="https://admin.${SYSTEM_DNS_ZONE_NAME}" \
                    CF_API_BASE_URL="https://api.${SYSTEM_DNS_ZONE_NAME}" \
                    ACCOUNTS_API_BASE_URL="https://accounts.${SYSTEM_DNS_ZONE_NAME}" \
                    ACCOUNTS_USERNAME="admin" \
                    ACCOUNTS_PASSWORD="$(awk '/^secrets_paas_accounts_admin_password:/ { print $2 }' < ../cf-vars-store/cf-vars-store.yml)" \
                      npm run test:acceptance

          - task: ensure-buildpacks-exist
            config:
              platform: linux
              image_resource: *cf-cli-image-resource
              inputs:
                - name: paas-cf
                - name: cf-vars-store
                - name: cf-manifest
              params:
                CF_ADMIN: admin
                SYSTEM_DNS_ZONE_NAME: ((system_dns_zone_name))
              run:
                path: bash
                args:
                  - -c
                  - |
                    set -ueo pipefail

                    CF_PASS=$(awk '/cf_admin_password/ {print $2}' cf-vars-store/cf-vars-store.yml | tr -d '"')
                    API_ENDPOINT="https://api.${SYSTEM_DNS_ZONE_NAME}"
                    echo | cf login -a "${API_ENDPOINT}" -u "${CF_ADMIN}" -p "${CF_PASS}" > /dev/null

                    cf buildpacks \
                       | awk '/_buildpack/ {print $1}' \
                       > actual_buildpacks.txt

                    ruby <<-RUBY
                    require 'yaml'
                    YAML
                      .load_file('cf-manifest/cf-manifest.yml')
                      .fetch('instance_groups', [])
                      .find { |g| g['name'] == 'api' }
                      .fetch('jobs', [])
                      .find { |j| j['name'] == 'cloud_controller_ng' }
                      .dig('properties', 'cc', 'install_buildpacks')
                      .map { |buildpack| buildpack['name'] }
                      .tap do |expected|
                        actual = File
                          .read('actual_buildpacks.txt')
                          .lines
                          .map(&:strip)
                          .to_a

                        puts 'Expected', '-----', expected, '-----'
                        puts 'Actual',   '-----', actual,   '-----'

                        buildpacks_not_found = expected - actual

                        if buildpacks_not_found.empty?
                          puts 'Found all buildpacks'
                          exit 0
                        else
                          puts "Could not find #{buildpacks_not_found.inspect}"
                          exit 1
                        end
                      end
                    RUBY

        ensure:
          task: remove-temp-user
          file: paas-cf/concourse/tasks/delete_admin.yml
          params:
            DISABLE_ADMIN_USER_CREATION: ((disable_custom_acceptance_tests))

  - name: bosh-tests
    plan:
      - aggregate:
          - get: pipeline-trigger
            passed: ['post-deploy','app-availability-tests','api-availability-tests']
            trigger: true
          - get: paas-cf
            passed: ['post-deploy','app-availability-tests','api-availability-tests']
          - get: cf-manifest
          - get: bosh-secrets
          - get: bosh-CA-crt
      - task: test-bosh-vms
        config:
          platform: linux
          image_resource: *gov-paas-bosh-cli-v2-image-resource
          inputs:
            - name: paas-cf
            - name: cf-manifest
            - name: bosh-secrets
            - name: bosh-CA-crt
          params:
            BOSH_ENVIRONMENT: ((bosh_fqdn))
            BOSH_CA_CERT: bosh-CA-crt/bosh-CA.crt
            BOSH_DEPLOYMENT: ((deploy_env))
          run:
            path: sh
            args:
              - -e
              - -c
              - |
                ./paas-cf/concourse/scripts/bosh_login.sh bosh-secrets/bosh-secrets.yml
                bosh deployment
                bosh vms | tee vms.txt
                vms_not_running=$(grep '|' vms.txt | grep -cEv '(\-\-|VM|running)' || true)
                if [ "${vms_not_running}" -gt "0" ]; then
                  echo "Error: Number of not running VMs: ${vms_not_running}."
                  exit 1
                else
                  echo "Success: All VMs are up and running."
                fi

  - name: performance-tests
    plan:
      - aggregate:
          - get: pipeline-trigger
            passed: ['smoke-tests', 'acceptance-tests', 'log-cache-acceptance-tests', 'custom-acceptance-tests', 'bosh-tests']
            trigger: true
          - get: paas-cf
            passed: ['smoke-tests', 'acceptance-tests', 'log-cache-acceptance-tests', 'custom-acceptance-tests', 'bosh-tests']
          - get: cf-manifest
            passed: ['smoke-tests', 'acceptance-tests', 'custom-acceptance-tests']
          - get: cf-vars-store
            passed: ['smoke-tests', 'acceptance-tests', 'custom-acceptance-tests']

      - do:
        - task: create-temp-user
          file: paas-cf/concourse/tasks/create_admin.yml
          params:
            PREFIX: performance-tests-user

        - task: generate-test-config
          file: paas-cf/concourse/tasks/generate-test-config.yml
          params:
            TEST_PROPERTIES: acceptance_tests
            APP_DOMAIN: ((apps_dns_zone_name))
            SYSTEM_DOMAIN: ((system_dns_zone_name))
            NAME_PREFIX: PERF

        - task: run-tests
          config:
            platform: linux
            image_resource: *cf-acceptance-tests-image-resource
            inputs:
              - name: paas-cf
              - name: test-config
            run:
              path: sh
              args:
                - -e
                - -c
                - |
                  echo "Running tests"
                  export CONFIG
                  CONFIG="$(pwd)/test-config/config.json"
                  ./paas-cf/platform-tests/run_tests.sh ./paas-cf/platform-tests/src/platform/performance/

        ensure:
          task: remove-temp-user
          file: paas-cf/concourse/tasks/delete_admin.yml

  - name: tag-release
    plan:
      - aggregate:
          - get: pipeline-trigger
            passed: ['performance-tests']
            trigger: true
          - get: paas-cf
            passed: ['performance-tests']
          - get: git-keys

      - put: release-version
        params: {bump: patch}

      - task: tag-release
        config:
          image_resource: *git-ssh-image-resource
          platform: linux
          params:
            aws_account: ((aws_account))
            deploy_env: ((deploy_env))
            OUTPUT_TAG_PREFIX: ((OUTPUT_TAG_PREFIX))
            INPUT_TAG_PREFIX: ((INPUT_TAG_PREFIX))
          inputs:
          - name: paas-cf
          - name: release-version
          - name: git-keys
          run:
            path: sh
            args:
            - -e
            - -c
            - |
              if [ -z "${OUTPUT_TAG_PREFIX}" ]; then
                echo \$OUTPUT_TAG_PREFIX not set, skipping
                exit 0
              fi
              paas-cf/concourse/scripts/tag_release.sh \
                "${OUTPUT_TAG_PREFIX}" "${aws_account}" "${deploy_env}" "${INPUT_TAG_PREFIX}"

  - name: pipeline-unlock
    serial: true
    plan:
      - get: pipeline-trigger
        passed: ['tag-release']
        trigger: true
      - get: pipeline-pool
      - task: update-datadog
        config:
          image_resource: *git-ssh-image-resource
          platform: linux
          params:
            DATADOG_API_KEY: ((datadog_api_key))
            ENV: ((deploy_env))
            AWS_ACCOUNT: ((aws_account))
            ENABLE_DATADOG: ((enable_datadog))
            PIPELINE_NAME: ((pipeline_name))
          inputs:
          - name: pipeline-pool
          run:
            path: sh
            args:
            - -e
            - -c
            - |
              cd pipeline-pool
              current_time=$(date +%s)
              lock_time=$(git log -1  --pretty=format:'%ct')
              delta=$((current_time - lock_time))
              echo "Total pipeline time was: ${delta}s"

              if [ "${ENABLE_DATADOG}" = "true" ]; then
                curl  -X POST -H "Content-type: application/json" \
                  -d "{ \"series\" :
                         [{\"metric\":\"concourse.pipeline_time\",
                          \"points\":[[$current_time, ${delta}]],
                          \"type\":\"gauge\",
                          \"tags\":[
                            \"deploy_env:${ENV}\",
                            \"pipeline_name:${PIPELINE_NAME}\",
                            \"aws_account:${AWS_ACCOUNT}\"
                          ]}
                        ]
                    }" \
                  "https://app.datadoghq.com/api/v1/series?api_key=${DATADOG_API_KEY}"
              fi
      - try:
          task: unlock-the-pipeline
          config:
            image_resource:
              type: docker-image
              source:
                repository: alpine
                tag: 3.7
            platform: linux
            params:
              DISABLE_PIPELINE_LOCKING: ((disable_pipeline_locking))
            run:
              path: sh
              args:
              - -e
              - -c
              - |
                if [ "${DISABLE_PIPELINE_LOCKING:-}" = "true" ] ; then
                   echo "Pipeline locking is disabled, this task will fail and this is OK."
                   exit 1
                fi
          on_success:
            put: pipeline-pool
            params:
              release: pipeline-pool

  - name: pipeline-check-lock
    plan:
      - get: pipeline-pool
      - task: print-pipeline-lock-state
        config:
          image_resource: *git-ssh-image-resource
          platform: linux
          inputs:
          - name: pipeline-pool
          run:
            path: sh
            args:
            - -e
            - -c
            - |
              if [ -f "pipeline-pool/((pipeline_name))/claimed/lock" ]; then
                current_status_message="LOCKED"
              elif [ -f "pipeline-pool/((pipeline_name))/unclaimed/lock" ]; then
                current_status_message="UNLOCKED"
              else
                echo "Error: Cannot find lock in pool: pipeline-pool/((pipeline_name))/{un,}claimed/lock"
                exit 1
              fi

              cd pipeline-pool
              export GIT_PAGER="cat"
              git log -1 --pretty=format:"
              Lock status is: ${current_status_message}

              Last commit change:
               - %cr at %ci
               - %s
              "

  - name: pipeline-release-lock
    plan:
      - get: pipeline-pool
      - put: pipeline-pool
        params:
          release: pipeline-pool

  - name: rotate-cf-admin-password
    serial: true
    plan:
    - aggregate:
      - get: paas-cf
      - get: cf-vars-store

    - task: generate-cf-admin-password
      config:
        platform: linux
        image_resource: *gov-paas-bosh-cli-v2-image-resource
        inputs:
          - name: cf-vars-store
        outputs:
          - name: rotated-cf-vars-store
        run:
          path: sh
          args:
            - -e
            - -c
            - |
              sed "s/^cf_admin_password:.*$//" cf-vars-store/cf-vars-store.yml \
                > rotated-cf-vars-store/rotated-cf-vars-store.yml

              bosh interpolate - --vars-store rotated-cf-vars-store/rotated-cf-vars-store.yml <<EOF
              ---
              variables:
              - name: cf_admin_password
                type: password
              EOF

    - task: update-cf-admin-password
      config:
        platform: linux
        image_resource:
          type: docker-image
          source:
            repository: governmentpaas/cf-uaac
            tag: 0eff5b6a9c092f865a2b19cc4e75a3b539b82fa2
        inputs:
          - name: paas-cf
          - name: rotated-cf-vars-store
        params:
          UAA_ENDPOINT: "https://uaa.((system_dns_zone_name))"
        run:
          path: sh
          args:
            - -e
            - -c
            - |
              VAL_FROM_YAML=$(pwd)/paas-cf/concourse/scripts/val_from_yaml.rb

              UAA_ADMIN_CLIENT_SECRET=$($VAL_FROM_YAML uaa_admin_client_secret rotated-cf-vars-store/rotated-cf-vars-store.yml)
              CF_ADMIN_PASSWORD=$($VAL_FROM_YAML cf_admin_password rotated-cf-vars-store/rotated-cf-vars-store.yml)

              uaac target "${UAA_ENDPOINT}"
              uaac token client get admin -s "${UAA_ADMIN_CLIENT_SECRET}"
              uaac password set admin -p "${CF_ADMIN_PASSWORD}"
      on_success:
        put: cf-vars-store
        params:
          file: rotated-cf-vars-store/rotated-cf-vars-store.yml

  - name: rotate-cloudfoundry-credentials
    serial: true
    plan:
    - aggregate:
      - get: paas-cf
        passed: ['rotate-cf-admin-password']
      - get: cf-secrets
      - get: cf-vars-store
        passed: ['rotate-cf-admin-password']
        trigger: true
      - get: cf-manifest-pre-vars
      - get: cf-tfstate

    - task: rotate-credentials
      config:
        platform: linux
        image_resource: *ruby-slim-image-resource
        inputs:
          - name: paas-cf
          - name: cf-secrets
          - name: cf-vars-store
          - name: cf-manifest-pre-vars
        outputs:
          - name: modified-cf-secrets
          - name: modified-cf-vars-store
        run:
          path: sh
          args:
            - -e
            - -c
            - |
              ./paas-cf/manifests/cf-manifest/scripts/rotate-cf-secrets.rb < \
                cf-secrets/cf-secrets.yml > \
                modified-cf-secrets/cf-secrets.yml
              ./paas-cf/manifests/cf-manifest/scripts/rotate-vars-store-secrets.rb \
                --vars-store cf-vars-store/cf-vars-store.yml \
                --manifest cf-manifest-pre-vars/cf-manifest-pre-vars.yml \
                --passwords \
                --ssh \
                --rsa \
                --preserve cc_bulk_api_password \
                --preserve cc_db_encryption_key \
                --preserve cc_internal_api_password \
                --preserve cc_staging_upload_password \
                --preserve cf_admin_password \
                --preserve cf_bosh_password \
                --preserve consul_encrypt_key \
                --preserve diego_bbs_encryption_keys_passphrase \
                --preserve diego_ssh_proxy_host_key \
                --preserve nats_password \
                --preserve router_route_services_secret \
                --preserve router_status_password \
                --preserve secrets_aiven_broker_admin_password \
                --preserve secrets_cdn_broker_admin_password \
                --preserve secrets_elasticache_broker_admin_password \
                --preserve secrets_rds_broker_admin_password \
                --preserve secrets_rds_broker_master_password_seed \
                --preserve secrets_rds_broker_state_encryption_key \
                --preserve secrets_uaa_clients_cdn_broker_secret \
                --preserve secrets_uaa_clients_datadog_firehose_password \
                --preserve uaa_admin_client_secret \
                --preserve uaa_clients_cc-routing_secret \
                --preserve uaa_clients_cc-service-dashboards_secret \
                --preserve uaa_clients_cc_service_key_client_secret \
                --preserve uaa_clients_cloud_controller_username_lookup_secret \
                --preserve uaa_clients_doppler_secret \
                --preserve uaa_clients_gorouter_secret \
                --preserve uaa_clients_network_policy_secret \
                --preserve uaa_clients_paas_admin_secret \
                --preserve uaa_clients_routing_api_client_secret \
                --preserve uaa_clients_ssh-proxy_secret \
                --preserve uaa_clients_tcp_emitter_secret \
                --preserve uaa_clients_tcp_router_secret \
                --preserve uaa_default_encryption_passphrase \
                > modified-cf-vars-store/cf-vars-store.yml
      on_success:
        do:
        - put: cf-secrets
          params:
            file: modified-cf-secrets/cf-secrets.yml
        - put: cf-vars-store
          params:
            file: modified-cf-vars-store/cf-vars-store.yml

    - task: forget-access-keys
      file: paas-cf/concourse/tasks/forget-access-keys.yml
      params:
        AWS_DEFAULT_REGION: ((aws_region))
      ensure:
        put: cf-tfstate
        params:
          file: updated-tfstate/cf.tfstate

  - name: expire-aws-keys
    serial: true
    plan:
    - aggregate:
      - get: paas-cf
      - get: cf-tfstate
      - get: expire-aws-keys-timer
        trigger: true
    - task: forget-access-keys
      file: paas-cf/concourse/tasks/forget-access-keys.yml
      params:
        AWS_DEFAULT_REGION: ((aws_region))
      ensure:
        put: cf-tfstate
        params:
          file: updated-tfstate/cf.tfstate

  - name: rotate-cf-certs-cas
    serial: true
    plan:
    - aggregate:
      - get: paas-cf
      - get: cf-manifest-pre-vars
      - get: cf-vars-store
    - task: rotate-cf-certs
      config:
        platform: linux
        image_resource: *ruby-slim-image-resource
        inputs:
          - name: paas-cf
          - name: cf-manifest-pre-vars
          - name: cf-vars-store
        outputs:
          - name: updated-cf-certs
        run:
          path: sh
          args:
            - -e
            - -c
            - |
              ./paas-cf/manifests/cf-manifest/scripts/rotate-vars-store-secrets.rb --ca \
                --manifest cf-manifest-pre-vars/cf-manifest-pre-vars.yml \
                --vars-store cf-vars-store/cf-vars-store.yml \
                > updated-cf-certs/cf-vars-store.yml
      on_success:
        put: cf-vars-store
        params:
          file: updated-cf-certs/cf-vars-store.yml

  - name: rotate-cf-certs-leafs
    serial: true
    plan:
    - aggregate:
      - get: paas-cf
      - get: cf-manifest-pre-vars
      - get: cf-vars-store
    - task: rotate-cf-certs
      config:
        platform: linux
        image_resource: *ruby-slim-image-resource
        inputs:
          - name: paas-cf
          - name: cf-manifest-pre-vars
          - name: cf-vars-store
        outputs:
          - name: updated-cf-certs
        run:
          path: sh
          args:
            - -e
            - -c
            - |
              ./paas-cf/manifests/cf-manifest/scripts/rotate-vars-store-secrets.rb --leaf \
                --manifest cf-manifest-pre-vars/cf-manifest-pre-vars.yml \
                --vars-store cf-vars-store/cf-vars-store.yml \
                > updated-cf-certs/cf-vars-store.yml
      on_success:
        put: cf-vars-store
        params:
          file: updated-cf-certs/cf-vars-store.yml

  - name: delete-old-cf-certs
    serial: true
    plan:
    - aggregate:
      - get: paas-cf
      - get: cf-manifest-pre-vars
      - get: cf-vars-store
    - task: rotate-cf-certs
      config:
        platform: linux
        image_resource: *ruby-slim-image-resource
        inputs:
          - name: paas-cf
          - name: cf-manifest-pre-vars
          - name: cf-vars-store
        outputs:
          - name: updated-cf-certs
        run:
          path: sh
          args:
            - -e
            - -c
            - |
              ./paas-cf/manifests/cf-manifest/scripts/rotate-vars-store-secrets.rb --delete \
                --manifest cf-manifest-pre-vars/cf-manifest-pre-vars.yml \
                --vars-store cf-vars-store/cf-vars-store.yml \
                > updated-cf-certs/cf-vars-store.yml
      on_success:
        put: cf-vars-store
        params:
          file: updated-cf-certs/cf-vars-store.yml

  - name: generate-git-keys
    plan:
      - task: ssh-keygen
        config:
          image_resource: *git-ssh-image-resource
          platform: linux
          outputs:
          - name: generated-git-keys
          run:
            path: sh
            args:
            - -e
            - -c
            - |
              ssh-keygen -t rsa -b 4096 -f git-key -N ''
              tar -cvzf generated-git-keys/git-keys.tar.gz ./git-key ./git-key.pub
              cat ./git-key.pub
        on_success:
          put: git-keys
          params:
            file: generated-git-keys/git-keys.tar.gz

  - name: bump-major-version
    plan:
      - put: release-version
        params: {bump: major}

  - name: bump-minor-version
    plan:
      - put: release-version
        params: {bump: minor}

  - name: bump-patch-version
    plan:
      - put: release-version
        params: {bump: patch}

  - name: show-release-version
    plan:
      - get: release-version

      - task: show-release-version
        config:
          platform: linux
          inputs:
            - name: release-version
          run:
            path: cat
            args:
            - release-version/number

  - name: continuous-smoke-tests
    serial_groups: [smoke-tests]
    build_logs_to_retain: 10000
    plan:
      - aggregate:
        - get: smoke-tests-timer
          trigger: true
        - get: deployed-healthcheck
        - get: cf-smoke-tests-release
        - get: paas-cf
          passed: ['pipeline-lock']
        - get: cf-manifest
          passed: ['post-deploy']
        - get: cf-vars-store
          passed: ['post-deploy']

      - task: assert-should-run
        config:
          platform: linux
          image_resource:
            type: docker-image
            source:
              repository: alpine
              tag: 3.7
          inputs:
            - name: deployed-healthcheck
          params:
            PERSISTENT_ENVIRONMENT: ((persistent_environment))
          run:
            path: sh
            args:
            - -e
            - -c
            - |
              HEALTHCHECK_DEPLOYED=$(cat deployed-healthcheck/healthcheck-deployed)
              if [ "$HEALTHCHECK_DEPLOYED" = "no" ] && [ "$PERSISTENT_ENVIRONMENT" != "true" ]; then
                echo "Healthcheck is not deployed and this is not a persistent environment"
                echo "Skipping smoke tests"
                exit 1
              fi
      - do:
        - task: create-temp-user
          file: paas-cf/concourse/tasks/create_admin.yml
          params:
            PREFIX: cont-smoketest-user

        - task: smoke-tests-config
          file: paas-cf/concourse/tasks/generate-test-config.yml
          params:
            TEST_PROPERTIES: smoke_tests
            APP_DOMAIN: ((apps_dns_zone_name))
            SYSTEM_DOMAIN: ((system_dns_zone_name))

        - task: smoke-tests-run
          file: paas-cf/concourse/tasks/smoke-tests-run.yml
          on_failure:
            task: alert
            config:
              platform: linux
              image_resource: *awscli-image-resource
              params:
                AWS_DEFAULT_REGION: ((aws_region))
                DEPLOY_ENV: ((deploy_env))
                SYSTEM_DNS_ZONE_NAME: ((system_dns_zone_name))
                ALERT_EMAIL_ADDRESS: ((ALERT_EMAIL_ADDRESS))
              inputs:
                - name: paas-cf
              run:
                path: sh
                args:
                - -e
                - -c
                - |
                  paas-cf/concourse/scripts/smoke_tests_email.sh \
                    "${DEPLOY_ENV}" "${SYSTEM_DNS_ZONE_NAME}" "${ALERT_EMAIL_ADDRESS}"
          ensure:
            task: upload-test-artifacts
            file: paas-cf/concourse/tasks/upload-test-artifacts.yml
            params:
              TEST_ARTIFACTS_BUCKET: ((test_artifacts_bucket))

        ensure:
          task: remove-temp-user
          file: paas-cf/concourse/tasks/delete_admin.yml

  - name: check-certificates
    build_logs_to_retain: 50
    plan:
      - aggregate:
        - get: check-certificates-timer
          trigger: true
        - get: paas-cf
          # passed: ['generate-cf-config']
        - get: cf-vars-store
          # passed: ['generate-cf-config']
        - get: ipsec-CA

      - task: check-certificates
        config:
          platform: linux
          image_resource: *ruby-slim-image-resource
          inputs:
            - name: paas-cf
            - name: cf-vars-store
            - name: ipsec-CA
          run:
            path: sh
            args:
              - -e
              - -c
              - |
                ./paas-cf/concourse/scripts/check-certificates.rb 30 < cf-vars-store/cf-vars-store.yml

                tar -xzf ./ipsec-CA/ipsec-CA.tar.gz -C ./ipsec-CA
                cat <<EOF > ipsec_cert.yml
                ---
                ipsec:
                  certificate: |
                $(sed 's/^/    /' ipsec-CA/ipsec-CA.crt)
                EOF

                ./paas-cf/concourse/scripts/check-certificates.rb 30 < ipsec_cert.yml

  - name: health-snapshot
    serial: true
    build_logs_to_retain: 25
    plan:
      - get: health-snapshot-timer
        trigger: true
      - get: bosh-secrets
      - get: bosh-CA-crt
      - get: vpc-tfstate
      - task: generate-snapshot-json
        timeout: 3m
        params:
          BOSH_ENVIRONMENT: ((bosh_fqdn))
          BOSH_CA_CERT: bosh-CA-crt/bosh-CA.crt
          BOSH_DEPLOYMENT: ((deploy_env))
          AWS_DEFAULT_REGION: ((aws_region))
        config:
          platform: linux
          image_resource: *awscli-image-resource
          inputs:
            - name: bosh-secrets
            - name: bosh-CA-crt
            - name: vpc-tfstate
          outputs:
            - name: health-snapshot-data
          run:
            path: sh
            args:
              - -e
              - -u
              - -c
              - |
                log() { echo "$@" 1>&2; }

                bosh_curl(){
                  path="$1"
                  out="$2"
                  bosh_password=$(awk '/bosh_admin_password/ { print $2 }' < bosh-secrets/bosh-secrets.yml)
                  bosh_api="https://admin:${bosh_password}@${BOSH_ENVIRONMENT}:25555"
                  curl -o "${out}" --dump-header response.headers --fail --silent --show-error --cacert "${BOSH_CA_CERT}" "${bosh_api}${path}"
                  if grep -q '302 Moved' < response.headers; then
                    task_path=$(awk '/Location/ { print $2 }' < response.headers | sed -E 's|https://[^/]+||')
                    while true; do
                      curl -o task.data --fail --silent --show-error --cacert "${BOSH_CA_CERT}" "${bosh_api}${task_path}"
                      log "waiting for task to complete: $(cat task.data)"
                      if [ "$(jq -r .state < task.data)" = "done" ]; then
                        break
                      fi
                      sleep 1
                    done
                    curl -o result.jsonl --fail --silent --show-error --cacert "${BOSH_CA_CERT}" "${bosh_api}${task_path}/output?type=result"
                    jq -s . result.jsonl > "${out}"
                  fi
                }

                yaml2json(){
                  python -c 'import sys, yaml, json; y=yaml.load(sys.stdin.read()); print json.dumps(y)'
                }

                log "fetching bosh state..."
                bosh_curl "/deployments/${BOSH_DEPLOYMENT}/instances?format=full" instances.json
                bosh_curl "/deployments/${BOSH_DEPLOYMENT}/vms?format=full" vms.json

                log "extracting details from cloud config..."
                bosh_curl "/configs?latest=true" configs.json
                jq -r '.[] | select(.type == "cloud") | .content' < configs.json | yaml2json | jq .azs > azs.json
                jq -r '.[] | select(.type == "cloud") | .content' < configs.json | yaml2json | jq '[.vm_extensions[] | select(.cloud_properties.elbs) | {name: .name, elbs: .cloud_properties.elbs}]' > elb_extensions.json
                jq -r '.[] | select(.type == "cloud") | .content' < configs.json | yaml2json | jq '[.vm_types[] | {name: .name, elbs: .cloud_properties.elbs, type: .cloud_properties.instance_type}]' > vm_types.json

                log "fetching aws state..."
                vpc_id=$(jq -r '.modules[0].outputs.vpc_id.value' vpc-tfstate/vpc.tfstate)
                aws elb describe-load-balancers --query "LoadBalancerDescriptions[?VPCId=='${vpc_id}']" > elbs.json
                aws ec2 describe-instances --filters "Name=vpc-id,Values=${vpc_id}" | jq '[.Reservations[].Instances[]]' > ec2.json

                log "building state json..."
                jq -s "{ \
                  bosh: { \
                    instances:.[0], \
                    vms: .[1], \
                    azs: .[2], \
                    elbs: .[3], \
                    vm_types: .[4], \
                  }, \
                  aws: { \
                    elbs: .[5], \
                    ec2: .[6], \
                  } \
                }" \
                  instances.json \
                  vms.json \
                  azs.json \
                  elb_extensions.json \
                  vm_types.json \
                  elbs.json \
                  ec2.json \
                > health-snapshot-data/health-snapshot-data.json

                log "OK"
      - put: health-snapshot-data
        params:
          file: health-snapshot-data/health-snapshot-data.json
      - task: sign-snapshot-url
        params:
          URL: s3://((state_bucket))/health-snapshot-data.json
        config:
          platform: linux
          image_resource: *awscli-image-resource
          outputs:
            - name: health-snapshot-secrets
          run:
            path: sh
            args:
              - -e
              - -u
              - -c
              - |
                secrets_file="health-snapshot-secrets/health-snapshot-secrets.yml"
                echo "generating secrets to access health snapshot data"
                echo "granting access to ${URL} for 7 days"
                one_week="604800"
                signed_url=$(aws s3 presign --expires-in "${one_week}" "${URL}")
                echo "---" > $secrets_file
                echo "snapshot_url: ${signed_url}" >> $secrets_file
      - put: health-snapshot-secrets
        params:
          file: health-snapshot-secrets/health-snapshot-secrets.yml
